Blackcat user's guide
=====================

Abstract: In this document you will find basic information about how to use blackcat in order to
          protect your data.

Wtf is this?
============

Talking about cryptography, I am paranoid. I have been spending some years studying a little this
subject and more a study more paranoid I become. This tool is merely a file encryptor with my own
paranoid cares about how to actually encrypt data stored in a filesystem.

I hate letting all files unencrypted when using encrypting tools based on storage devices. If you
are paranoid like me, maybe you will like the way of how blackcat works.

The general approach of this tool is provide you a way of protecting an entire directory and its
sub-directories. Due to it, I have designed the application to work similarly as a SCM tool,
excluding all version control stuff, of course.

OK, you do not know what a SCM tool is. Forget about the concepts. I will try to introduce you the
basic usage workflow even so.

The usage workflow
==================

Basically you need to create a directory into your filesystem or use a pre-existent one. For this
time we will be using a new one.

Thus, I will create a new one here:

    root@RedBarn:~/# mkdir sphinx
    root@RedBarn:~/# cd sphinx
    root@RedBarn:~/sphinx# _

Now we need to turn the sphinx directory into a blackcat repo. A blackcat repo is a directory
where blackcat is able to work on by locking and unlocking files among other additional operations
(more on that later). The act of turning an ordinary directory as a blackcat repo is called
initialization, initialisation or for short 'init'.

Blackcat works based on commands. All time you call blackcat you also need to specify what you are
intending to do. Thus, the first argument of the command line is always your intention a.k.a. the
command. If that command expects additional parameters you need to pass them too.

Let's init the sphinx directory:

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=sha-384 --protection-layer-hash=whirlpool \
    > --protection-layer=aes-256-cbc
    root@RedBarn:~/sphinx# _

Two distinct passwords will be asked to you and after it the previous ordinary/flat directory will
become a blackcat repo.

Blackcat is a unix-like tool, if it stays quiet after a command it means that the command has worked.
We do not like to set fireworks when a thing works, neither celebrate with tons of exclamations!!!!!!
This is... w
            e i
                r
                 d .
                    .
                    .

After running a well succeeded init command in an ordinary directory a sub-directory called .bcrepo
will be created. This directory stores the catalog data. You should not edit it on your own. For
example, do you have the habit of poking your cat's sandbox with your nose? So...

Maybe you are curious about the options present in command init.

    --catalog-hash -> Specifies the hash function used by the catalog password (the first key).

    --key-hash     -> Specifies the hash function used by the user encryption key (the second key).

    --protection-layer-hash -> Specifies the hash function used internally by the protection
                               processors (key crunching, got it?).

    --protection-layer -> Specifies the algorithm or the sequence of the cascading. Yes, you can
                          specify more than one. This protection layer will be used to encrypt
                          the sensible data inside the current repository. When you specify more
                          than one cipher they need to be separated by commas.

Blackcat verifies if the combination of those three hashing algorithms are considered strong. If
not the init command will fail and you will be warned.

Blackcat uses the following algorithm naming convention:

                            <algorithm>-<bit-size-if-it-has-one>-<mode>

Blackcat also implements HMACs and (in this case) the naming convention is:

                hmac-<hash-algorithm>-<algorithm>-<bit-size-if-it-has-one>-<mode>

Until now blackcat only implements the following encryption operation modes: cbc, ctr, ofb.

The application counts with more than one thousand encryption schemes to be used in your
protection layer.

If you do not need a barrier of two passwords you can force blackcat to use only one key. What can
be done by specifying the option flag '--keyed-alike'. By default a blackcat repo is "keyed-twice".

Now we got a directory where some files or whole files stored under it can be encrypted. However is
also possible put files without cataloging it. When you catalog a file, blackcat will track this.
The application will inform you the status of the file besides, of course, encrypt and decrypt the
related data.

The way of adding a file to the repo's catalog is through the command 'add':

    root@RedBarn:~/sphinx# blackcat add my-secret-spell.txt
    root@RedBarn:~/sphinx# blackcat add src/p-equals-to-np-final-proof.bf
    root@RedBarn:~/sphinx# blackcat add backyard/*.conf cat-memes/*.gif cat-memes/*.jpeg
    root@RedBarn:~/sphinx# blackcat add --plain YOU_SHALL_NOT_PASS_DISCLAIMER

Before adding, the repo's password will be asked. Once added to the catalog the files can be protected.
If you run the command 'status' you will see that all files added are currently "unlocked".

As you can see, even sub-directories inside the blackcat repo are automatically considered (if some
file inside them have added to the repo's catalog).

The '--plain' option flag indicates to blackcat that the added file(s) must not be protected. Only
indexed.

The simplest way of checking the status of the indexed files is as follows:

    root@RedBarn:~/sphinx# blackcat status

The 'status' command also can be called passing a glob pattern, in cases where you have tons of files
added to the catalog, a glob can be useful.

The color code used in blackcat's status report is the same of semaphores:

    - Red (stop, no one will pass there, the file data is currently locked).
    - Yellow (attention, eavesdroppers can roam freely there, you should
              lock it if you are not using the unlocked file(s) anymore).
    - Green (go, anyone can pass, it is free).

If for some reason you have added a wrong file to the catalog or that file is not relevant anymore.
Use the command 'rm':

    root@RedBarn:~/sphinx# blackcat rm cat-memes/*.gif

If you want to lock all indexed files, use the 'lock' command:

    root@RedBarn:~/sphinx# blackcat lock

After typing the password(s), if correct, all non plain files will be locked.

The 'lock' command also accepts glob patterns.

In order to unlock a file use the 'unlock' command:

    root@RedBarn:~/sphinx# blackcat unlock src/p-equals-to-np-final-proof.bf

The 'unlock' command also accepts glob patterns.

A good practice is always run a 'blackcat lock' when you have just finished of accessing the repo.
Just saying, however, the data is yours and you are totally free to do anything you want with it.

When you are not lazy and only unlock the relevant data of your repo, you are leaking the minimal
secrecy possible from the repo, if someone is silent downloading your files, this data disclosure
will be a catastrophe, for sure, but not so huge as it could be. If you are paranoid about your
data, it is a pretty good feature (but only explored if you apply some usage care).

Now you know all basic usage workflow:

    -> Initializing a repository.
    -> Adding files to the repository's catalog.
    -> Removing them when necessary.
    -> Locking & unlocking your sensible data.

Let's move to more advanced features.

With so many encryption schemes, how can I remember the exact name of one?
==========================================================================

Blackcat implements a command called 'show'. With the 'show' command you can list some capabilities
present in your blackcat's copy. Since blackcat is an encrypting tool its capabilities are related
to ciphers, hmacs schemes, hashes and also encoders. The command will list the exact name of how a
specific algorithm/scheme is internally recognized by blackcat.

Let's show all implemented encoders:

    root@RedBarn:~/sphinx# blackcat show encoders
    uuencode
    base64
    root@RedBarn:~/sphinx# _

Further on I will show you how to use encoding algorithms in blackcat. By now you should only know
that they exist.

When you need to initialize a repo it is necessary to indicate three hashing algorithms, if you want
to see the menu before picking one:

    root@RedBarn:~/sphinx# blackcat show hashes
    sha-224
    sha-256
    (...)
    root@RedBarn:~/sphinx# _

HMACs can be used in a protection layer, listing all currently available:

    root@RedBarn:~/sphinx# blackcat show hmacs
    hmac-sha-224-aes-128-cbc
    hmac-sha-256-aes-128-cbc
    hmac-sha-384-aes-128-cbc
    hmac-sha-512-aes-128-cbc
    hmac-sha3-224-aes-128-cbc
    hmac-sha3-256-aes-128-cbc
    hmac-sha3-384-aes-128-cbc
    hmac-sha3-512-aes-128-cbc
    hmac-tiger-aes-128-cbc
    hmac-whirlpool-aes-128-cbc
    hmac-sha-224-aes-192-cbc
    hmac-sha-256-aes-192-cbc
    hmac-sha-384-aes-192-cbc
    hmac-sha-512-aes-192-cbc
    hmac-sha3-224-aes-192-cbc
    hmac-sha3-256-aes-192-cbc
    hmac-sha3-384-aes-192-cbc
    hmac-sha3-512-aes-192-cbc
    hmac-tiger-aes-192-cbc
    hmac-whirlpool-aes-192-cbc
    hmac-sha-224-aes-256-cbc
    hmac-sha-256-aes-256-cbc
    hmac-sha-384-aes-256-cbc
    hmac-sha-512-aes-256-cbc
    hmac-sha3-224-aes-256-cbc
    hmac-sha3-256-aes-256-cbc
    hmac-sha3-384-aes-256-cbc
    hmac-sha3-512-aes-256-cbc
    hmac-tiger-aes-256-cbc
    hmac-whirlpool-aes-256-cbc
    hmac-sha-224-des-cbc
    hmac-sha-256-des-cbc
    hmac-sha-384-des-cbc
    hmac-sha-512-des-cbc
    hmac-sha3-224-des-cbc
    (...)
    root@RedBarn:~/sphinx# _


In order to list all ciphers (including the HMAC schemes):

    root@RedBarn:~/sphinx# blackcat show ciphers
    arc4
    seal
    rabbit
    aes-128-cbc
    aes-192-cbc
    aes-256-cbc
    des-cbc
    3des-cbc
    3des-ede-cbc
    idea-cbc
    rc2-cbc
    rc5-cbc
    rc6-128-cbc
    rc6-192-cbc
    rc6-256-cbc
    feal-cbc
    cast5-cbc
    camellia-128-cbc
    camellia-192-cbc
    camellia-256-cbc
    safer-k64-cbc
    blowfish-cbc
    serpent-cbc
    tea-cbc
    xtea-cbc
    misty1-cbc
    mars-128-cbc
    mars-192-cbc
    mars-256-cbc
    present-80-cbc
    present-128-cbc
    shacal1-cbc
    shacal2-cbc
    noekeon-cbc
    noekeon-d-cbc
    aes-128-ofb
    aes-192-ofb
    aes-256-ofb
    des-ofb
    (...)
    gibberish-wrap
    root@RedBarn:~/sphinx# _

I know: "Wtf is 'gibberish-wrap'?!". It is not actually a cipher. It is just about a way of
wrapping the sensible data with pseudo-random bytes. The gibberish-wrap expects two arguments:

    1. how many bytes will wrap the data more left.
    2. how many bytes will wrap the data more right.

This is the way of indicating a practical 'gibberish wrapping':

            gibberish-wrap/723-636

By the way, some implemented ciphers also need additional parameters that you need to specify in
the same way of how is specified in 'gibberish-wrap'. The general idea is:

            <algorithm-with-additional-parameters>/<p_0>-<p_1>-...-<p_n>

For example:

            hmac-rc6-192-cbc/512

In the case of RC6 you are specifying the rounds total.

Paranoid practices
==================

It is not a good practice to use blackcat with your shell history enabled. The problem is that
some eavesdropper can track what files you have been editing and also some details about the
initialization of some repository. Actually this is not a failure, since the details of the
protection layer can offer a shortcut from impossible to an infeasible brute force attack. However
if we can avoid giving some clue about the protection layer to the attacker, why not?

The way of disabling the shell history is:

    root@RedBarn:~/sphinx# blackcat paranoid --disable-history
    root@RedBarn:~/sphinx# _

After executing this command the shell history will be disabled and all your subsequent command
will not be recorded.

In order to activate the shell history again:

    root@RedBarn:~/sphinx# blackcat paranoid --enable-history
    root@RedBarn:~/sphinx# _

Blackcat also counts with a device driver that helps us with our paranoid worries. The support
device driver is available for FreeBSD, Linux and NetBSD.

This device driver offers the possibility of detecting hooks that could be used in order to log
your passwords and also some nice 'incantations' to hide your file and/or repositories.

The blackcat device driver should be loaded through the kernel module called 'blackcat.ko'
(FreeBSD and Linux), 'blackcat.kmod' (NetBSD). The way of loading it is as follows:

    root@RedBarn:~/sphinx# blackcat lkm --load <path to the kernel module>

If you have defined the environment variable 'BLACKCAT_LKM_PATH' the path to the kernel module
should be omitted from the command line. The environment variable must store the path to the
kernel module, of course.

You can also use the native loader of your operating system (insmod/modprobe, kldload, modload).

Once loaded the lkm cannot be unloaded unless you reboot your machine. It will stay resident.
This property is necessary, otherwise an intruder could be able to silent unload it and hacking
you. Now that your blackcat has some kernel mode powers, let's learn how to use them.

As I start saying before, in most of cases, encryption systems are exploited by side-channel
attacks or even exploting bad practices followed by users. The brute force for civilians
is expensive, so they will try to find some failure in your workflow usage.

When they are unable to guess a password because that password seems not be as lousy as the
majority and you take into consideration all good practices, they can try to log it directly
from your machine. Usually some hooking is done in some syscalls. You can detect this kind of
attack by running the command 'paranoid' with its sub-command '--find-hooks':

    root@RedBarn:~/sphinx# blackcat paranoid --find-hooks
    root@RedBarn:~/sphinx# _

If '--find-hooks' has found some bad stuff you will be informed. Notice that some methods
such as memory patching until now are not considered by the scanner. Do not take the
verdict of it as an absolute truth.

This command only will work with the device driver previously loaded. Bear in mind that if
you have a rootkit installed into your system you have failed a bunch while user/admin.
Stop reading this and go burn this machine immediately and learn more about best practices
related to information security.

Supposing that you are editing your sensible data into a system and silent someone is connected
probing your filesystem, downloading everything that looks interesting. What about a mechanism
that makes the sensible data invisible to an external attacker?

So you can hide specific files into a repository or even the entire repository.

Hiding a specific file:

    root@RedBarn:~/sphinx# blackcat paranoid --bury etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

After running this command if you try to perform some listing, stating over the file
'grandma-cake-recipe.txt' nothing will be found, however, you can still edit it. People
connected through SSH, Telnet or FTP will not be able to see, find or download the file.

The '--bury' sub-command also supports glob patterns.

The only way of making the 'grandma-cake-recipe.txt' visible again is by using the
sub-command '--dig-up':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

The sub-command '--dig-up' also supports globs, but in this case you should pass the
exact glob used with '--bury', otherwise the file will stay invisible.

A good thing to do is create a repository with a crazy name, harder to guess about and
make it entirely invisible through the sub-command '--bury-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --bury-repo
    root@RedBarn:~/sphinx# _

After this command the directory 'sphinx' will not be able to be listed, stated or even
saw by connected people.

In order to make a repository visible again, use the sub-command '--dig-up-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up-repo
    root@RedBarn:~/sphinx# _

Again, those paranoid commands are not a kind of silver bullet against your sloppiness
when talking about information security. If your system is so hacked that it has
screen loggers, rootkits and so on, you should re-think if computers are tools that you
really should be able to use without harming yourself and other people.

The problem of using encryption tools in modern operating systems is the possibility of
leaking some sensible information (e.g.: keys) to secondary storage devices. How does it
can happen? Simple, as instance, if your system decides to swap the data into the RAM to
the disk, the key will be recorded in disk and someone (smart enough) would be able to
recover this information using it to access your repo.

Blackcat offers two ways of mitigating this cumbersome property:

    1. Giving to the blackcat process a high priority, with it the process will use
       more time of CPU before being scheduled for next execution.

    2. Disabling the swap through Posix's mlockall.

In order to give a high priority to blackcat you should use the flag '--set-high-priority':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --set-high-priority
    root@RedBarn:~/sphinx# _

In order to disable memory swap use the flag '--no-swap':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --no-swap
    root@RedBarn:~/sphinx# _

When using '--no-swap', any memory allocated by the application will stay in memory even
during a swap operation. However, you must avoid suspending or hibernating your system, in
this case, your current session will be saved to some point into your disk.
