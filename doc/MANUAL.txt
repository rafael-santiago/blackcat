Blackcat user's guide
=====================

(obvious) Abstract: In this document you will find basic information about how to use the blackcat
                    command line tool and its subsystems.

Wtf is this?
============

Talking about cryptography, I am paranoid. I have been spending some years studying a little this
subject and more a study more paranoid I become. This tool is merely a file encryptor with my own
paranoid cares about how to actually encrypt data stored in a filesystem.

I hate letting all files unencrypted when using encrypting tools based on storage devices. If you
are paranoid like me, maybe you will like the way of how blackcat works.

The general approach of this tool is to provide you a way of protecting an entire directory and
its sub-directories. Due to it, I have designed the application to work similarly as a scm tool,
excluding all version control stuff, of course.

OK, you do not know what a scm tool is. Forget about the concepts. I will try to introduce you the
basic usage workflow even so.

The usage workflow
==================

Basically you need to create a directory into your filesystem or use a pre-existent one. For this
time we will be using a new one.

Thus, I will create a new one here:

    root@RedBarn:~/# mkdir sphinx
    root@RedBarn:~/# cd sphinx
    root@RedBarn:~/sphinx# _

Now we need to turn the sphinx directory into a blackcat repo. A blackcat repo is a directory
where blackcat is able to work on by locking and unlocking files among other additional operations
(more on that later). The act of turning an ordinary directory as a blackcat repo is called
initialization, initialisation or for short 'init'.

Blackcat works based on commands. When you call blackcat you also need to specify what you are
intending to do. Thus, the first argument of the command line is always your intention a.k.a. the
command. If that command expects additional parameters you need to pass them too.

Let's init the sphinx directory:

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=sha-384 --protection-layer-hash=whirlpool \
    > --protection-layer=aes-256-cbc
    root@RedBarn:~/sphinx# _

Two distinct passwords will be asked to you and after it the previous ordinary/flat directory will
become a blackcat repo.

Blackcat is a unix-like tool, if it stays quiet after a command it means that the command has worked.
We do not like to set fireworks when a thing works, neither celebrate with tons of exclamations!!!!!!
This is... w
            e i
                r
                 d .
                    .
                    .

After running a well succeeded init command in an ordinary directory a sub-directory called .bcrepo
will be created. This directory stores the catalog data. You should not edit it on your own. For
example, do you have the habit of poking your cat's sandbox with your nose? So...

Maybe you are curious about the options present in command init.

    --catalog-hash -> Specifies the hash function used by the catalog password (the first key).

    --key-hash     -> Specifies the hash function used to store the user encryption key
                      (the second key).

    --protection-layer-hash -> Specifies the hash function used internally by the protection
                               processors (key crunching, got it?).

    --protection-layer -> Specifies the algorithm or the sequence of the cascading. Yes, you can
                          specify more than one. This protection layer will be used to encrypt
                          the sensible data inside the current repository. When you specify more
                          than one cipher they need to be separated by commas.

Blackcat verifies if the combination of those three hashing algorithms are considered strong. If
not the init command will fail and you will be warned.

Blackcat uses the following algorithm naming convention:

                            <algorithm>-<bit-size-if-it-has-one>-<mode>

Blackcat also implements HMACs and (in this case) the naming convention is:

                hmac-<hash-algorithm>-<algorithm>-<bit-size-if-it-has-one>-<mode>

Until now blackcat only implements the following encryption operation modes: cbc, ctr, ofb.

The application counts with more than one thousand encryption schemes to be used in your
protection layer.

If you do not need a barrier of two passwords you can force blackcat to use only one key. What can
be done by specifying the option flag '--keyed-alike'. By default a blackcat repo is "keyed-twice".

Some people when talking about password hashing get wet only by hearing the word "bcrypt". Well,
if you are this kind of people, the '--key-hash' option supports bcrypt, "ooh wee!!" would say
Mr. Poopy Butthole. Yes, it supports but in this case is necessary to pass the bcrypt's cost
through the option '--bcrypt-cost':

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=bcrypt --bcrypt-cost=8 \
    > --protection-layer-hash=whirlpool \
    > --protection-layer=aes-256-cbc
    root@RedBarn:~/sphinx# _

Sorry pure people, the last paragraph was... a kind of humid, huh? It will never happen again,
because from now on I will not approach any subject related to... b  c  r  y  p  t...

Let's move on.

Now we got a directory where some files or whole files stored under it can be encrypted. However is
also possible put files without cataloging it. When you catalog a file, blackcat will track this.
The application will inform you the status of the file besides, of course, encrypt and decrypt the
related data.

The way of adding a file to the repo's catalog is through the command 'add':

    root@RedBarn:~/sphinx# blackcat add my-secret-spell.txt --lock
    root@RedBarn:~/sphinx# blackcat add src/p-equals-to-np-final-proof.bf
    root@RedBarn:~/sphinx# blackcat add backyard/*.conf cat-memes/*.gif cat-memes/*.jpeg
    root@RedBarn:~/sphinx# blackcat add --plain YOU_SHALL_NOT_PASS_DISCLAIMER

Before adding, the repo's password will be asked. Once added to the catalog the files can be protected.
If you run the command 'status' you will see that all files added are currently "unlocked".

As you can see, even sub-directories inside the blackcat repo are automatically considered (if some
file inside them have added to the repo's catalog).

The '--lock' option flag encrypts all files added by the current add command.

The '--plain' option flag indicates to blackcat that the added file(s) must not be protected. Only
indexed.

The simplest way of checking the status of the indexed files is as follows:

    root@RedBarn:~/sphinx# blackcat status

The 'status' command also can be called passing a glob pattern, in cases where you have tons of files
added to the catalog, a glob can be useful.

The color code used in blackcat's status report is the same of semaphores:

    - Red (stop, no one will pass there, the file data is currently locked).
    - Yellow (attention, eavesdroppers can roam freely there, you should
              lock it if you are not using the unlocked file(s) anymore).
    - Green (go, anyone can pass, it is free).

If for some reason you have added a wrong file to the catalog or that file is not relevant anymore.
Use the command 'rm':

    root@RedBarn:~/sphinx# blackcat rm cat-memes/*.gif

If you want to lock all indexed files, use the 'lock' command:

    root@RedBarn:~/sphinx# blackcat lock

After typing the password(s), if correct, all non plain files will be locked.

The 'lock' command also accepts glob patterns.

In order to unlock a file use the 'unlock' command:

    root@RedBarn:~/sphinx# blackcat unlock src/p-equals-to-np-final-proof.bf

The 'unlock' command also accepts glob patterns.

A good practice is always run a 'blackcat lock' when you have just finished of accessing the repo.
Just saying, however, the data is yours and you are totally free to do anything you want with it.

When you are not lazy and only unlock the relevant data of your repo, you are leaking the minimal
secrecy possible from the repo, if someone is silent downloading your files, this data disclosure
will be a catastrophe, for sure, but not so huge as it could be. If you are paranoid about your
data, it is a pretty good feature (but only explored if you apply some usage care).

Now you know all basic usage workflow:

    -> Initializing a repository.
    -> Adding files to the repository's catalog.
    -> Removing them when necessary.
    -> Locking & unlocking your sensible data.

Let's move to more advanced features.

With so many encryption schemes, how can I remember the exact name of one?
==========================================================================

Blackcat implements a command called 'show'. With the 'show' command you can list some capabilities
present in your blackcat's copy. Since blackcat is an encrypting tool its capabilities are related
to ciphers, hmacs schemes, hashes and also encoders. The command will list the exact name of how a
specific algorithm/scheme is internally recognized by blackcat.

Let's show all implemented encoders:

    root@RedBarn:~/sphinx# blackcat show encoders
    uuencode
    base64
    root@RedBarn:~/sphinx# _

Further on I will show you how to use encoding algorithms in blackcat. By now you should only know
that they exist.

When you need to initialize a repo it is necessary to indicate three hashing algorithms, if you want
to see the menu before picking one:

    root@RedBarn:~/sphinx# blackcat show hashes
    sha-224
    sha-256
    (...)
    root@RedBarn:~/sphinx# _

HMACs can be used in a protection layer, listing all currently available:

    root@RedBarn:~/sphinx# blackcat show hmacs
    hmac-sha-224-aes-128-cbc
    hmac-sha-256-aes-128-cbc
    hmac-sha-384-aes-128-cbc
    hmac-sha-512-aes-128-cbc
    hmac-sha3-224-aes-128-cbc
    hmac-sha3-256-aes-128-cbc
    hmac-sha3-384-aes-128-cbc
    hmac-sha3-512-aes-128-cbc
    hmac-tiger-aes-128-cbc
    hmac-whirlpool-aes-128-cbc
    hmac-sha-224-aes-192-cbc
    hmac-sha-256-aes-192-cbc
    hmac-sha-384-aes-192-cbc
    hmac-sha-512-aes-192-cbc
    hmac-sha3-224-aes-192-cbc
    hmac-sha3-256-aes-192-cbc
    hmac-sha3-384-aes-192-cbc
    hmac-sha3-512-aes-192-cbc
    hmac-tiger-aes-192-cbc
    hmac-whirlpool-aes-192-cbc
    hmac-sha-224-aes-256-cbc
    hmac-sha-256-aes-256-cbc
    hmac-sha-384-aes-256-cbc
    hmac-sha-512-aes-256-cbc
    hmac-sha3-224-aes-256-cbc
    hmac-sha3-256-aes-256-cbc
    hmac-sha3-384-aes-256-cbc
    hmac-sha3-512-aes-256-cbc
    hmac-tiger-aes-256-cbc
    hmac-whirlpool-aes-256-cbc
    hmac-sha-224-des-cbc
    hmac-sha-256-des-cbc
    hmac-sha-384-des-cbc
    hmac-sha-512-des-cbc
    hmac-sha3-224-des-cbc
    (...)
    root@RedBarn:~/sphinx# _


In order to list all ciphers (including the HMAC schemes):

    root@RedBarn:~/sphinx# blackcat show ciphers
    arc4
    seal
    rabbit
    aes-128-cbc
    aes-192-cbc
    aes-256-cbc
    des-cbc
    3des-cbc
    3des-ede-cbc
    idea-cbc
    rc2-cbc
    rc5-cbc
    rc6-128-cbc
    rc6-192-cbc
    rc6-256-cbc
    feal-cbc
    cast5-cbc
    camellia-128-cbc
    camellia-192-cbc
    camellia-256-cbc
    safer-k64-cbc
    blowfish-cbc
    serpent-cbc
    tea-cbc
    xtea-cbc
    misty1-cbc
    mars-128-cbc
    mars-192-cbc
    mars-256-cbc
    present-80-cbc
    present-128-cbc
    shacal1-cbc
    shacal2-cbc
    noekeon-cbc
    noekeon-d-cbc
    aes-128-ofb
    aes-192-ofb
    aes-256-ofb
    des-ofb
    (...)
    gibberish-wrap
    root@RedBarn:~/sphinx# _

I know: "Wtf is 'gibberish-wrap'?!". It is not actually a cipher. It is just about a way of
wrapping the sensible data with pseudo-random bytes. The gibberish-wrap expects two arguments:

    1. how many bytes will wrap the data more left.
    2. how many bytes will wrap the data more right.

This is the way of indicating a practical 'gibberish wrapping':

            gibberish-wrap/723-636

By the way, some implemented ciphers also need additional parameters that you need to specify in
the same way of how is specified in 'gibberish-wrap'. The general idea is:

            <algorithm-with-additional-parameters>/<p_0>-<p_1>-...-<p_n>

For example:

            hmac-rc6-192-cbc/512

In the case of RC6 you are specifying the rounds total.

Paranoid practices
==================

It is not a good practice to use blackcat with your shell history enabled. The problem is that
some eavesdropper can track what files you have been editing and also some details about the
initialization of some repository. Actually this is not a failure, since the details of the
protection layer can offer a shortcut from the impossible to the infeasible brute force attack.
However if we can avoid giving some clue about the protection layer to the attacker, why not?

The way of disabling the shell history is:

    root@RedBarn:~/sphinx# blackcat paranoid --disable-history
    root@RedBarn:~/sphinx# _

After executing this command the shell history will be disabled and all your subsequent command
will not be recorded.

In order to activate the shell history again:

    root@RedBarn:~/sphinx# blackcat paranoid --enable-history
    root@RedBarn:~/sphinx# _

Blackcat also counts with a device driver that helps us with our paranoid worries. The support
device driver is available for FreeBSD, Linux and NetBSD.

This device driver offers the possibility of detecting hooks that could be used in order to log
your passwords and also some nice 'incantations' to hide your file and/or repositories.

The blackcat device driver should be loaded through the kernel module called 'blackcat.ko'
(FreeBSD and Linux), 'blackcat.kmod' (NetBSD). The way of loading it is as follows:

    root@RedBarn:~/sphinx# blackcat lkm --load <path to the kernel module>

If you have defined the environment variable 'BLACKCAT_LKM_PATH' the path to the kernel module
should be omitted from the command line. The environment variable must store the path to the
kernel module, of course.

You can also use the native loader of your operating system (insmod/modprobe, kldload, modload).

Once loaded the lkm cannot be unloaded unless you reboot your machine. It will stay resident.
This property is necessary, otherwise an intruder could be able to silent unload it and hacking
you. Now that your blackcat has some kernel mode powers, let's learn how to use them.

As I start saying before, in most of cases, encryption systems are exploited by side-channel
attacks or even exploting bad practices followed by users. The brute force for civilians
is expensive, so they will try to find some failure in your workflow usage.

When they are unable to guess a password because that password seems not be as lousy as the
majority and you take into consideration all good practices, they can try to log it directly
from your machine. Usually some hooking is done in some syscalls. You can detect this kind of
attack by running the command 'paranoid' with its sub-command '--find-hooks':

    root@RedBarn:~/sphinx# blackcat paranoid --find-hooks
    root@RedBarn:~/sphinx# _

If '--find-hooks' has found some bad stuff you will be informed. Notice that some methods
such as memory patching until now are not considered by the scanner. Do not take the
verdict of it as an absolute truth.

This command only will work with the device driver previously loaded. Bear in mind that if
you have a rootkit installed into your system you have failed a bunch while user/admin.
Stop reading this and go burn this machine immediately and learn more about best practices
related to information security.

Supposing that you are editing your sensible data into a system and silent someone is connected
probing your filesystem, downloading everything that looks interesting. What about a mechanism
that makes the sensible data invisible to an external attacker?

So you can hide specific files into a repository or even the entire repository.

Hiding a specific file:

    root@RedBarn:~/sphinx# blackcat paranoid --bury etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

After running this command if you try to perform some listing, stating over the file
'grandma-cake-recipe.txt' nothing will be found, however, you can still edit it. People
connected through SSH, Telnet or FTP will not be able to see, find or download the file.

The '--bury' sub-command also supports glob patterns.

The only way of making the 'grandma-cake-recipe.txt' visible again is by using the
sub-command '--dig-up':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

The sub-command '--dig-up' also supports globs, but in this case you should pass the
exact glob used with '--bury', otherwise the file will stay invisible.

A good thing to do is create a repository with a crazy name, harder to guess about and
make it entirely invisible through the sub-command '--bury-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --bury-repo
    root@RedBarn:~/sphinx# _

After this command the directory 'sphinx' will not be able to be listed, stated or even
saw by connected people.

In order to make a repository visible again, use the sub-command '--dig-up-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up-repo
    root@RedBarn:~/sphinx# _

Again, those paranoid commands are not a kind of silver bullet against your sloppiness
when talking about information security. If your system is so hacked that it has
screen loggers, rootkits and so on, you should re-think if computers are tools that you
really should be able to use without harming yourself and other people.

The problem of using encryption tools in modern operating systems is the possibility of
leaking some sensible information (e.g.: keys) to secondary storage devices. How does it
can happen? Simple, as instance, if your system decides to swap the data into the RAM to
the disk, the key will be recorded in disk and someone (smart enough) would be able to
recover this information using it to access your repo.

Blackcat offers two ways of mitigating this cumbersome property:

    1. Giving to the blackcat process a high priority, with it the process will use
       more time of CPU before being scheduled for next execution.

    2. Disabling the swap through Posix's mlockall.

In order to give a high priority to blackcat you should use the flag '--set-high-priority':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --set-high-priority
    root@RedBarn:~/sphinx# _

In order to disable memory swap use the flag '--no-swap':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --no-swap
    root@RedBarn:~/sphinx# _

When using '--no-swap', any memory allocated by the application will stay in RAM even
during a swap operation. However, you must avoid suspending or hibernating your system, in
this case, your current session will be saved to some point into your disk.

Encoding your stuff after encrypting
====================================

Until now only the two most known encoding algorithms are available: 'uuencode' and 'base64'.

Enconding data could be useful for some applications, imagine you are versioning the data
with some scm and hosting those data somewhere (a way of making a private repo without
paying a single dollar for it, err... but do not tell anyone that I told you...); the encoding
algorithm will let the repository more friendly for the web.

Here goes a 'init' command passing the encoder:

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-384 \
    > --key-hash=whirlpool \
    > --protection-layer-hash=sha-512 \
    > --protection-layer=aes-128-cbc \
    > --encoder=uuencode
    root@RedBarn:~/sphinx# _

As you can see this section also could be titled 'Saving some bucks'.

Changing your keys
==================

Maybe change your repo key(s) would be a best practice. The command 'setkey' offers you
this possibility.

Supposing you have a 'keyed-twice' repo and you want to redefine the two passwords:

    root@RedBarn:~/sphinx# blackcat setkey
    (The two current passwords will be asked and so the two new passwords and them confirmations
     will be asked too)
    root@RedBarn:~/sphinx# _

If from now on you want to use only one password:

    root@RedBarn:~/sphinx# blackcat setkey --keyed-alike
    (The two current passwords will be asked and so the new password and its confirmation
     will be asked)
    root@RedBarn:~/sphinx# _

With the 'setkey' command is also possible to reconfigure other repository properties. All
property defined during its initialization ('init') can be redefined with 'setkey'.

The way of changing a property is by expliciting it through command line. If some repo property
was informed it will be redefined too. The properties are the same options recognized by 'init'
command: '--catalog-hash', '--key-hash', '--protection-layer-hash', '--protection-layer' and
'--encoder'.

A way of reseting the repository:

    root@RedBarn:~/sphinx# blackcat setkey --keyed-alike \
    > --catalog-hash=whirlpool \
    > --key-hash=sha-512 \
    > --protection-layer-hash=tiger \
    > --encoder=uuencode \
    > --protection-layer=camellia-192-cbc,mars-192-cbc,misty1-ctr,hmac-sha3-512-aes-256-cbc
    (Guess what?)
    root@RedBarn:~/sphinx# _

How can I redefine those properties without redefining the key(s)? Simple, type the current
key(s) anyway. Wow.

Transfering your data to another environment
============================================

It seems obvious, because you can easily zip/tar your repository and you done, however, blackcat
also offers you a more structured way of doing this. You can pack the entire repo into a single
file and after unpack this file, re-creating also the structure from the previous packed repo.

In order to pack execute the following command:

    root@RedBarn:~/sphinx# blackcat pack packed-sphinx.bc
    root@RedBarn:~/sphinx# _

After running the command above the file 'packed-sphinx.bc' will be created and now you are
able to save, send your repo just by using this single flat file.

When you pack a repo all unlocked data is previously locked before packing all stuff. Do not
worry about it.

Supposing you want to restore a repo from a previous packed data:

    root@RedBarn:~/# blackcat unpack packed-sphinx.bc sphinx
    root@RedBarn:~/# cd sphinx
    root@RedBarn:~/sphinx# Ya hey! ;)

So during the 'unpack' command you need to specify the packed file and the directory path were the
repository will be re-created.

Undo
====

No program is perfect. In cases of abnormal termination, it is possible to recover the file that was
being processed at the moment blackcat has aborted. The command is pretty simple:

    root@RedBarn:~/sphinx# blackcat undo
    root@RedBarn:~/sphinx# _

Blackcat generates a checkpoint at every file processing (encrypting and decrypting).

In cases when blackcat does not exit normally you should immediately execute an 'undo'.

When there is some file to be recovered you will not be able to process any other file before
executing an 'undo' command.

Getting info about the repo
===========================

If for some reason you want to know some meta-info about your blackcat repo, things such as version,
used hashes, protection layer, etc. Try the command 'info':

    root@RedBarn:~/sphinx# blackcat info
    (some info...)
    root@RedBarn:~/sphinx# _

Your password will be asked before providing the information.

Decoy files
===========

Blackcat has a command that allows you creating decoy files that are totally random but for an
unsuspecting attacker is almost impossible to separate this kind of data from real cryptograms.
The most obvious utility of decoy files is to add noise during a possible repo cryptanalysis.
Maybe a cryptanalyst could spend days, months or even years on pure chaff. The usage is as follows:

    root@RedBarn:~/sphinx# blackcat decoy chunk-001.txt chunk-002.txt --fsize=4096
    root@RedBarn:~/sphinx# _

The 'decoy' command for avoiding data loss does not overwrite files automatically you need to explicity
ask for it through '--overwrite' flag option:

    root@RedBarn:~/sphinx# blackcat decoy chunk-001.txt chunk-002.txt --fsize=8192 --overwrite
    root@RedBarn:~/sphinx# _

If you are using some kind of encoding for your sensible data is a good idea also generate encoded
decoys (using the same encoded algorithm used for sensible data, of course):

    root@RedBarn:~/sphinx# blackcat decoy doc/report.txt --encoder=uuencode --fsize=193
    root@RedBarn:~/sphinx# _

After doing it all you should do is to add the generated decoy files as plain files to the repo's
catalog by using the command 'add'.

Protecting network traffic
==========================

Blackcat is able to protect data flowing from network connections. The basic idea behind the net
module is to protect applications by running them through blackcat. In this case any socket function
related to send/receive data is intercepted by 'libbcsck.so', the library with socket stuff but including
some crypto capabilities.

When you protect network traffic with blackcat you must indicate which protection rule will be applied over
that communication channel. Due to it you need to create a rule and store this rule inside a file that is
commonly called 'netdb'. A kind of database with rules that can protect net data.

The command to create a rule is 'net/--add-rule':

    root@RedBarn:~/# blackcat net --add-rule --rule=nc --type=socket --hash=whirlpool \
    > --protection-layer=blowfish,aes-128-ctr,hmac-sha3-512-aes-256-cbc --db-path=netdb.db

It will create a file called 'netdb.db' with a rule called 'nc' of type 'socket'. Until now only type
'socket' is supported. The '--protection-layer' option specifies what algorithm(s) will be used to
protect data. The '--hash' option indicates the hash algorithm used by the key derivation function.

When you specify an existing file in the '--db-path' option your new rule will be appended to the
existing ones.

If for some reason you want to delete a rule:

    root@RedBarn:~/# blackcat net --drop-rule --rule=nc --db-path=netdb.db

Pretty easy, huh?

Now let's see how to use a rule to protect a connection. As said before blackcat will apply
some hooking stuff to make the connection encrypted. Let's suppose that Alice wants to communicate
with Bob just by using netcat but she also wants some level of secrecy during this chat. Alice
should use the command 'net/--run' to create a protected instance of netcat in her system:

    root@RedBarn:~/# blackcat net --run --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc -l -p 1024

Just after executing the command above Alice will be asked for the netdb's password and also a
session key (previously agreed between Bob and her). Notice that the command invoking the external
application must be passed after all blackcat options.

Bob also runs the netcat wrapped by blackcat. Indicating the same netdb rule and session key
agreed with Alice:

    root@SkyValley:~/# blackcat net --run --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc alice.workstation 1024

After the connection is well estabilished, every data exchanged between each other will be
encrypted following the netdb rule.

The option '--bcsck-lib-path' can be omitted and by default blackcat will scan its socket library
in '/usr/lib'. If you want to overwrite the default you should define an environment variable called
'BLACKCAT_BCSCK_LIB_HOME'.

Similarly, the option '--db-path' can be omitted when you define an environment variable called
'BLACKCAT_NET_DB_HOME'.

BEWARE: The 'net/--run' sample given above does not protect you against replay attacks. If you
want to protect the communication against this kind of attack you should flag your intention by
using the option flag '--e2ee'. This will force the blackcat to use an ephemeral key for each
exchanged data. The command becomes a little bit different:

    root@RedBarn:~/# blackcat net --run --e2ee --xchg-port=50 --rule=nc \
    > --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc -l -p 1024

Now Alice has used '--e2ee' option and also she has indicated a control port number through the
option '--xchg-port'. This port number will be used during a necessary initial negotiation.

The command for Bob also changes a little:

    root@SkyValley:~/# blackcat net --run --e2ee --xchg-port=50 --xchg-addr=alice.workstation \
    > --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc alice.workstation 1024

Bob, being the client must pass three additional flags: '--e2ee', '--xchg-port' and '--xchg-addr'.

The '--xchg-port' must contain the same value picked by Alice. The '--xchg-addr' must contain the
Alice's network address.

Once well estabilished the connection, each message exchanged between each other will be encrypted
with a double ratchet mechanism. When some key is re-used a warning is displayed. Alerting the user
about a possible replay attack, in this case is better to close the connection immediately.

The first usage mode also must be considered an end to end encryption (E2EE), however, the second
usage ensures a little bit better that nothing can be done with the channel, in regards to data or
connection manipulation.

Cool off
========

Maybe you have heard from someone that knows somebody that have told about the existence of software
able to guess up the used encryption algorithm just by scanning the software used for performing the
encryption. 'Wooow!!'... joking...

Those software just scan the executable text trying to find some algorithm constant which behaves like
a signature. Pretty boring. It is useless and do not offer any risk for well implemented crypto, since
modern encryption takes into consideration the Kasiski's principles. Thus even knowing the used
algorithm, if the attacker does not know the key, the attack must be infeasible to her/him.

Of course that blackcat has all constants of all implemented algorithms in its text. What an attacker
should do is to perform a brute force against the first key and if there is a second key they must
guess up the algorithm(s) (when more than one, the right used sequence is necessary, too).

It tends to be a little bit hard because

        "if you don't know where you are going, any road " + may + " get you there"

What the best way of knowing that this specific road is not the right road? Simple, find the end of it.
If at the end you did not find anything. It is time to go back and try another road.

Nice, for the first time Alice was the attacker. Eve was revenged! ;)

Few tips for not being a tracked average sheep out there
========================================================

The nice stuff about blackcat is to add to your workflow the possibility of using strong data protection
with few easy command primitives. It does not require any special container for your data, mounting it,
etc; an ordinary directory becomes protected and you can easily encrypt and decrypt independent files
or file groups. Init it, add and just go.

If you like automating your work, adding blackcat to your state of things is pretty easy.

For example, it is straightforward to integrate blackcat with some scm tool. The nice part is that you
can host a private repository without paying for your privacy. I find privacy is basic, it is a
right and you should not pay for it. In my opinion it is shameful.

Nowadays everyone likes to send data to the cloud. However, if you have sensible stuff or very personal
data you should encrypt it. Do not be fool, believing that all your data is securely stored and that
no one would be able to access it. Systems are full of bugs and people in majority tends to be crooked.
Moreover, some systems/companies just like to eavesdrop us because we are profitable while users.
In this case, use the cloud but encrypt what is relevant to you. Also put a bunch of false clues just
for screwing up some nosy AI hahaha I love doing it when hosting data that could be probed. Everyone
should do the same, just for making the web more "friendly" again.

Using crypto is a way of saying: if you want to apply your tracking policy over me you will need to do
it more directed buddy and if you want to track naïve people, nice but not me, because I am using
crypto. Your fishing net must be thinner for catching me up.
