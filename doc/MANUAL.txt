                             @2
                            MMM
                        aMMMMMM
                      ZMMMMMMMMM0
                     @MMMMMMMMMMMM
                    rMMMMMMMMMMMMM
                   MMMMMMMMMMMMMMMM
               XMMMMMMMMMMMMMMMMMM
           @MMMMMMMMMMMMMMMMMM
         MMMMMMMMMMMMMMMMMMMMM
       ZMMMMMMMMMMMMMMMMMMMMMM
      :MMMMMMMMMMMMMMMMMMMMM0           B  l  a  c  k  c  a  t   u  s  e  r'  s   g  u  i  d  e
     0MMMMMMMMMMMMMMMMMMMMM            = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    MMMMMMMMMMMMMMMMMMMMMM
   MMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMM;
  MMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMM8
  MMMMMMMMMMMMMMMMMM                i,
  MMMMMMMMMMMMMMM MM               MMMM
 MMMMMMMMMMMMMMB  MM i             MMM0
rMMMMMMMMMMMMMMMMrMMMMM           MMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX

(obvious) Abstract: In this document you will find basic information about how to use the blackcat
                    command line tool and its subsystems.

Wtf is that?
============

Talking about cryptography, I am paranoid. I have been spending some years studying a little this
subject and more a study more paranoid I become. This tool is merely a file encryptor with my own
paranoid cares about how to actually encrypt data stored in a filesystem.

I hate letting all files exposed when using encryption tools based on storage devices. If you are
paranoid like me, maybe you will like the way of how blackcat works.

The general approach of this tool is to provide you a way of protecting an entire directory and
its sub-directories. Due to it, I have designed the application for working similarly as a scm
tool, excluding all version control stuff, of course.

OK, you do not know what a scm tool is. Forget about the concepts. I will try to introduce you the
basic usage workflow even so.

The usage workflow
==================

Basically you need to create a directory into your filesystem or use a pre-existent one. For this
time we will be using a new one.

Thus, I will create a new one here:

    root@RedBarn:~/# mkdir sphinx
    root@RedBarn:~/# cd sphinx
    root@RedBarn:~/sphinx# _

Now we need to turn the sphinx directory into a blackcat repo. A blackcat repo is a directory
where blackcat is able to work on by locking and unlocking files among other additional operations
(more on that later). The act of turning an ordinary directory as a blackcat repo is called
initialization, initialisation or for short 'init'.

Blackcat works based on commands. When you call blackcat you also need to specify what you are
intending to do. Thus, the first argument of the command line is always your intention a.k.a. the
command. If that command expects additional parameters you need to pass them too.

Let's init the sphinx directory:

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=sha-384 --protection-layer-hash=whirlpool \
    > --protection-layer=aes-256-cbc
    root@RedBarn:~/sphinx# _

Two distinct passwords will be asked to you and after it the previous ordinary/flat directory will
become a blackcat repo.

Blackcat is a unix-like tool, if it stays quiet after a command it means that the command has worked.
We do not like to set fireworks when a thing works, neither celebrate with tons of exclamations!!!!!!
This is... w
            e i
                r
                 d .
                    .
                    .

After running a well succeeded init command in an ordinary directory a sub-directory called .bcrepo
will be created. This directory stores the catalog data. You should not edit it on your own. For
example, do you have the habit of poking your cat's sandbox with your nose? So...

Maybe you are curious about the options present in command init.

    --catalog-hash -> Specifies the hash function used by the catalog password (the first key).

    --key-hash     -> Specifies the hash function used to store the user encryption key
                      (the second key).

    --protection-layer-hash -> Specifies the hash function used internally by the protection
                               processors (key crunching, got it?).

    --protection-layer -> Specifies the algorithm or the sequence of the cascading. Yes, you can
                          specify more than one. This protection layer will be used to encrypt
                          the sensitive data inside the current repository. When you specify more
                          than one cipher they need to be separated by commas.

Blackcat verifies if the combination of those three hashing algorithms are considered strong. If
not the init command will fail and you will be warned.

Blackcat uses the following algorithm naming convention:

                            <algorithm>-<bit-size-if-it-has-one>-<mode>

Blackcat also implements HMACs and (in this case) the naming convention is:

                hmac-<hash-algorithm>-<algorithm>-<bit-size-if-it-has-one>-<mode>

Until now blackcat only implements the following encryption operation modes: cbc, ctr, ofb and
gcm (for ciphers suitable with this mode).

The application counts with more than one thousand encryption schemes to be used in your
protection layer.

If you do not need a barrier of two passwords you can force blackcat use only one key. What can
be done by specifying the option flag '--keyed-alike'. By default a blackcat repo is "keyed-twice".

If you prefer using bcrypt for password hashing, the option '--key-hash' supports it. In this case is
necessary to pass the bcrypt's cost through the option '--bcrypt-cost':

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=bcrypt --bcrypt-cost=8 \
    > --protection-layer-hash=whirlpool \
    > --protection-layer=aes-256-cbc
    root@RedBarn:~/sphinx# _

Now we got a directory where some files or whole files stored under it can be encrypted. However is
also possible put files without cataloging it. When you catalog a file, blackcat will track this.
The application will inform you the status of the file besides, of course, encrypt and decrypt the
related data.

The way of adding a file to the repo's catalog is through the command 'add':

    root@RedBarn:~/sphinx# blackcat add my-secret-spell.txt --lock
    root@RedBarn:~/sphinx# blackcat add src/p-equals-to-np-final-proof.bf
    root@RedBarn:~/sphinx# blackcat add backyard/*.conf cat-memes/*.gif cat-memes/*.jpeg
    root@RedBarn:~/sphinx# blackcat add --plain YOU_SHALL_NOT_PASS_DISCLAIMER

Before adding, the repo's password will be asked. Once added to the catalog the files can be protected.
If you run the command 'status' you will see that all files added are currently "unlocked".

As you can see, even sub-directories inside the blackcat repo are automatically considered (if some
file inside them have added to the repo's catalog).

The '--lock' option flag encrypts all files added by the current add command.

The '--plain' option flag indicates to blackcat that the added file(s) must not be protected. Only
indexed.

The simplest way of checking the status of the indexed files is as follows:

    root@RedBarn:~/sphinx# blackcat status

The 'status' command also can be called passing a glob pattern, in cases where you have tons of files
added to the catalog, a glob can be useful.

The color code used in blackcat's status report is the same of semaphores:

    - Red (stop, no one will pass there, the file data is currently locked).
    - Yellow (attention, eavesdroppers can roam freely there, you should
              lock it if you are not using the unlocked file(s) anymore).
    - Green (go, anyone can pass, it is free).

If for some reason you have added a wrong file to the catalog or that file is not relevant anymore.
Use the command 'rm':

    root@RedBarn:~/sphinx# blackcat rm cat-memes/*.gif

If you want to lock all indexed files, use the 'lock' command:

    root@RedBarn:~/sphinx# blackcat lock

After typing the password(s), if correct, all non plain files will be locked.

The 'lock' command also accepts glob patterns.

In order to unlock a file use the 'unlock' command:

    root@RedBarn:~/sphinx# blackcat unlock src/p-equals-to-np-final-proof.bf

The 'unlock' command also accepts glob patterns.

A good practice is always run a 'blackcat lock' when you have just finished of accessing the repo.
Just saying, however, the data is yours and you are totally free to do anything you want with it.

When you are not lazy and only unlock the relevant data of your repo, you are leaking the minimal
secrecy possible from the repo, if someone is silent downloading your files, this data disclosure
will be a catastrophe, for sure, but not so huge as it could be. If you are paranoid about your
data, it is a pretty good feature (but only explored if you apply some usage care).

Now you know all basic usage workflow:

    -> Initializing a repository.
    -> Adding files to the repository's catalog.
    -> Removing them when necessary.
    -> Locking & unlocking your sensitive data.

Let's move to more advanced features.

With so many encryption schemes, how can I remember the exact name of one?
==========================================================================

Blackcat implements a command called 'show'. With the 'show' command you can list some capabilities
present in your blackcat's copy. Since blackcat is an encryption tool its capabilities are related
to ciphers, hmacs schemes, hashes and also encoders. The command will list the exact name of how a
specific algorithm/scheme is internally recognized by blackcat.

Let's show all implemented encoders:

    root@RedBarn:~/sphinx# blackcat show encoders
    uuencode
    base64
    root@RedBarn:~/sphinx# _

Now let's show all available key derivation functions:

    root@RedBarn:~/sphinx# blackcat show kdfs
    hkdf
    pbkdf2
    argon2i
    root@RedBarn:~/sphinx# _

Further on I will show you how to use encoding algorithms in blackcat. By now you should only know
that they exist.

When you need to initialize a repo it is necessary to indicate three hashing algorithms, if you want
to see the menu before picking one:

    root@RedBarn:~/sphinx# blackcat show hashes
    sha-224
    sha-256
    (...)
    root@RedBarn:~/sphinx# _

HMACs can be used in a protection layer, listing all currently available:

    root@RedBarn:~/sphinx# blackcat show hmacs
    hmac-sha-224-aes-128-cbc
    hmac-sha-256-aes-128-cbc
    hmac-sha-384-aes-128-cbc
    hmac-sha-512-aes-128-cbc
    hmac-sha3-224-aes-128-cbc
    hmac-sha3-256-aes-128-cbc
    hmac-sha3-384-aes-128-cbc
    hmac-sha3-512-aes-128-cbc
    hmac-tiger-aes-128-cbc
    hmac-whirlpool-aes-128-cbc
    hmac-sha-224-aes-192-cbc
    hmac-sha-256-aes-192-cbc
    hmac-sha-384-aes-192-cbc
    hmac-sha-512-aes-192-cbc
    hmac-sha3-224-aes-192-cbc
    hmac-sha3-256-aes-192-cbc
    hmac-sha3-384-aes-192-cbc
    hmac-sha3-512-aes-192-cbc
    hmac-tiger-aes-192-cbc
    hmac-whirlpool-aes-192-cbc
    hmac-sha-224-aes-256-cbc
    hmac-sha-256-aes-256-cbc
    hmac-sha-384-aes-256-cbc
    hmac-sha-512-aes-256-cbc
    hmac-sha3-224-aes-256-cbc
    hmac-sha3-256-aes-256-cbc
    hmac-sha3-384-aes-256-cbc
    hmac-sha3-512-aes-256-cbc
    hmac-tiger-aes-256-cbc
    hmac-whirlpool-aes-256-cbc
    hmac-sha-224-des-cbc
    hmac-sha-256-des-cbc
    hmac-sha-384-des-cbc
    hmac-sha-512-des-cbc
    hmac-sha3-224-des-cbc
    (...)
    root@RedBarn:~/sphinx# _


In order to list all ciphers (including the HMAC schemes):

    root@RedBarn:~/sphinx# blackcat show ciphers
    arc4
    seal
    rabbit
    aes-128-cbc
    aes-192-cbc
    aes-256-cbc
    des-cbc
    3des-cbc
    3des-ede-cbc
    idea-cbc
    rc2-cbc
    rc5-cbc
    rc6-128-cbc
    rc6-192-cbc
    rc6-256-cbc
    feal-cbc
    cast5-cbc
    camellia-128-cbc
    camellia-192-cbc
    camellia-256-cbc
    safer-k64-cbc
    blowfish-cbc
    serpent-cbc
    tea-cbc
    xtea-cbc
    misty1-cbc
    mars-128-cbc
    mars-192-cbc
    mars-256-cbc
    present-80-cbc
    present-128-cbc
    shacal1-cbc
    shacal2-cbc
    noekeon-cbc
    noekeon-d-cbc
    aes-128-ofb
    aes-192-ofb
    aes-256-ofb
    des-ofb
    (...)
    gibberish-wrap
    root@RedBarn:~/sphinx# _

I know: "Wtf is 'gibberish-wrap'?!". It is not actually a cipher. It is just about a way of
wrapping the sensitive data with pseudo-random bytes. The gibberish-wrap expects two arguments:

    1. how many bytes will wrap the data more left.
    2. how many bytes will wrap the data more right.

This is the way of indicating a practical 'gibberish wrapping':

            gibberish-wrap/723-636

By the way, some implemented ciphers also need additional parameters that you need to specify in
the same way of how is specified in 'gibberish-wrap'. The general idea is:

            <algorithm-with-additional-parameters>/<p_0>-<p_1>-...-<p_n>

For example:

            hmac-rc6-192-cbc/512

In the case of RC6 you are specifying the rounds total.

An additional parameter gives support to escaped chars. In this way, when is necessary to pass a
byte sequence as a initialization vector for instance, you are not limited to printable ascii
range.

Take a look:

        rabbit/01234567

Rabbit cipher expects an IV of 64-bit size. The parameter sample above has low entropy, the best
would be use escaped chars to strengthen it:

        rabbit/r\x04\x0b\b\x01t$%

This is not a requirement, but an option.

How does the cascade actually work?
===================================

Until now there are two cascade types:

    - Single flow
    - One-time pad

When in single flow type blackcat will pick your cascade (protection-layer) and apply it over the
data following the order defined by you when initializing the repo. More straightforward, impossible.

When in one-time pad type blackcat will pick your cascade (protection-layer) and divide it into two
halves. After the application will generate a pseudo-random block with the size of the plaintext and
get the xoring between the random block and the plaintext. Once xored the plaintext, the random block
will be encrypted by using the first half of the cascade and the encrypted plaintext (xored) will be
encrypted with the second half of the cascade. Those two pieces of information will be serialized by
using the PEM format. Finally, this PEM buffer will be encrypted with the entire cascade and saved as
another PEM buffer. When applying the last encryption layer, the PEM buffer is wrapped by two random
blocks of variable sizes. The one-time pad cascade type is inspired by the method presented/introduced
by Bruce Schneier in his book Applied Cryptography.

If you are using an encoder for your repo and also have activated otp cascade type, the final PEM
buffer will be encoded.

Similarly, if you are using decoy files (keeping reading), those decoys will be generated following
the out format for encrypted files in otp cascade type. However, if you have changed for single flow,
any previous decoy material generated following the format of otp stuff will be kept.

Paranoid practices
==================

It is not a good practice to use blackcat with your shell history enabled. The problem is that
some eavesdropper can track what files you have been editing and also some details about the
initialization of some repository. Actually this is not a failure, since the details of the
protection layer can offer a shortcut from the impossible to the infeasible brute force attack.
However if we can avoid giving some clue about the protection layer to the attacker, why not?

The way of disabling the shell history is:

    root@RedBarn:~/sphinx# blackcat paranoid --disable-history
    root@RedBarn:~/sphinx# _

After executing this command the shell history will be disabled and all your subsequent command
will not be recorded.

In order to activate the shell history again:

    root@RedBarn:~/sphinx# blackcat paranoid --enable-history
    root@RedBarn:~/sphinx# _

Blackcat also counts with a device driver that helps us with our paranoid worries. The support
device driver is available for FreeBSD, Linux and NetBSD.

This device driver offers the possibility of detecting hooks that could be used in order to log
your passwords and also some nice 'incantations' that hide your file and/or repositories.

The blackcat device driver should be loaded through the kernel module called 'blackcat.ko'
(FreeBSD and Linux), 'blackcat.kmod' (NetBSD). The way of loading it is as follows:

    root@RedBarn:~/sphinx# blackcat lkm --load <path to the kernel module>

If you have defined the environment variable 'BLACKCAT_LKM_PATH' the path to the kernel module
should be omitted from the command line. The environment variable must store the path to the
kernel module, of course.

You can also use the native loader of your operating system (insmod/modprobe, kldload, modload).

Once loaded the lkm cannot be unloaded unless you reboot your machine. It will stay resident.
This property is necessary, otherwise an intruder could be able to silent unload it and hacking
you. Now that your blackcat has some kernel mode powers, let's learn how to use them.

As I start saying before, in most of cases, encryption systems are exploited by side-channel
attacks or even exploting bad practices followed by users. The brute force for civilians
is expensive, so they will try to find some failure in your workflow usage.

When they are unable to guess a password because that password seems not be as lousy as the
majority and you take into consideration all good practices, they can try to log it directly
from your machine. Usually some hooking is done in some syscalls. You can detect this kind of
attack by running the command 'paranoid' with its sub-command '--find-hooks':

    root@RedBarn:~/sphinx# blackcat paranoid --find-hooks
    root@RedBarn:~/sphinx# _

If '--find-hooks' has found some bad stuff you will be informed. Notice that some methods
such as memory patching until now are not considered by the scanner. Do not take the
verdict of it as an absolute truth.

This command only will work with the device driver previously loaded. Bear in mind that if
you have a rootkit installed into your system you have failed a bunch while user/admin.
Stop reading this and go burn this machine immediately and learn more about best practices
related to information security.

Supposing that you are editing your sensitive data into a system and silent someone is connected
probing your filesystem, downloading everything that looks interesting. What about a mechanism
that makes the sensitive data invisible to an external attacker?

So you can hide specific files into a repository or even the entire repository.

Hiding a specific file:

    root@RedBarn:~/sphinx# blackcat paranoid --bury etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

After running this command if you try to perform some listing, stating over the file
'grandma-cake-recipe.txt' nothing will be found, however, you can still edit it. People
connected through SSH, Telnet or FTP will not be able to see, find or download the file.

The '--bury' sub-command also supports glob patterns.

The only way of making the 'grandma-cake-recipe.txt' visible again is by using the
sub-command '--dig-up':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up etc/grandma-cake-recipe.txt
    root@RedBarn:~/sphinx# _

The sub-command '--dig-up' also supports globs, but in this case you should pass the
exact glob used with '--bury', otherwise the file will stay invisible.

A good thing to do is create a repository with a crazy name, harder to guess about and
make it entirely invisible through the sub-command '--bury-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --bury-repo
    root@RedBarn:~/sphinx# _

After this command the directory 'sphinx' will not be able to be listed, stated or even
saw by connected people.

In order to make a repository visible again, use the sub-command '--dig-up-repo':

    root@RedBarn:~/sphinx# blackcat paranoid --dig-up-repo
    root@RedBarn:~/sphinx# _

Again, those paranoid commands are not a kind of silver bullet against your sloppiness
when talking about information security. If your system is so hacked that it has
screen loggers, rootkits and so on, you should re-think if computers are tools that you
really should be able to use without harming yourself and other people.

The problem of using encryption tools in modern operating systems is the possibility of
leaking some sensitive information (e.g.: keys) to secondary storage devices. How does it
can happen? Simple, as instance, if your system decides to swap the data into the RAM to
the disk, the key will be recorded in disk and someone (smart enough) would be able to
recover this information using it to access your repo.

Blackcat offers two ways of mitigating this cumbersome property:

    1. Giving to the blackcat process a high priority, with it the process will use
       more time of CPU before being scheduled for next execution.

    2. Disabling the swap through Posix's mlockall.

In order to give a high priority to blackcat you should use the flag '--set-high-priority':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --set-high-priority
    root@RedBarn:~/sphinx# _

In order to disable memory swap use the flag '--no-swap':

    root@RedBarn:~/sphinx# blackcat <some command> <args> --no-swap
    root@RedBarn:~/sphinx# _

When using '--no-swap', any memory allocated by the application will stay in RAM even
during a swap operation. However, you must avoid suspending or hibernating your system, in
this case, your current session will be saved to some point into your disk.

Encoding your stuff after encrypting
====================================

Until now only the two most known encoding algorithms are available: 'uuencode' and 'base64'.

Enconding data could be useful for some applications, imagine you are versioning the data
with some scm and hosting those data somewhere (a way of making a private repo without
paying a single dollar for it, err... but do not tell anyone that I told you...); the encoding
algorithm will let the repository more friendly for the web.

Here goes a 'init' command passing the encoder:

    root@RedBarn:~/sphinx# blackcat init \
    > --catalog-hash=sha3-384 \
    > --key-hash=whirlpool \
    > --protection-layer-hash=sha-512 \
    > --protection-layer=aes-128-cbc \
    > --encoder=uuencode
    root@RedBarn:~/sphinx# _

As you can see this section also could be titled 'Saving some bucks'.

Changing your keys
==================

Maybe change your repo key(s) would be a best practice. The command 'setkey' offers you
this possibility.

Supposing you have a 'keyed-twice' repo and you want to redefine the two passwords:

    root@RedBarn:~/sphinx# blackcat setkey
    (The two current passwords will be asked and so the two new passwords and them confirmations
     will be asked too)
    root@RedBarn:~/sphinx# _

If from now on you want to use only one password:

    root@RedBarn:~/sphinx# blackcat setkey --keyed-alike
    (The two current passwords will be asked and so the new password and its confirmation
     will be asked)
    root@RedBarn:~/sphinx# _

With the 'setkey' command is also possible to reconfigure other repository properties. All
property defined during its initialization ('init') can be redefined with 'setkey'.

The way of changing a property is by expliciting it through command line. If some repo property
was informed it will be redefined too. The properties are the same options recognized by 'init'
command: '--catalog-hash', '--key-hash', '--protection-layer-hash', '--protection-layer' and
'--encoder'.

A way of reseting the repository:

    root@RedBarn:~/sphinx# blackcat setkey --keyed-alike \
    > --catalog-hash=whirlpool \
    > --key-hash=sha-512 \
    > --protection-layer-hash=tiger \
    > --encoder=uuencode \
    > --protection-layer=camellia-192-cbc,mars-192-cbc,misty1-ctr,hmac-sha3-512-aes-256-cbc
    (Guess what?)
    root@RedBarn:~/sphinx# _

How can I redefine those properties without redefining the key(s)? Simple, type the current
key(s) anyway. Wow.

Transfering your data to another environment
============================================

It seems obvious, because you can easily zip/tar your repository and you done, however, blackcat
also offers you a more structured way of doing this. You can pack the entire repo into a single
file and after unpack this file, re-creating also the structure from the previous packed repo.

In order to pack execute the following command:

    root@RedBarn:~/sphinx# blackcat pack packed-sphinx.bc
    root@RedBarn:~/sphinx# _

After running the command above the file 'packed-sphinx.bc' will be created and now you are
able to save, send your repo just by using this single flat file.

When you pack a repo all unlocked data is previously locked before packing all stuff. Do not
worry about it.

Supposing you want to restore a repo from a previous packed data:

    root@RedBarn:~/# blackcat unpack packed-sphinx.bc sphinx
    root@RedBarn:~/# cd sphinx
    root@RedBarn:~/sphinx# Ya hey! ;)

So during the 'unpack' command you need to specify the packed file and the directory path where the
repository will be re-created.

Undo
====

No program is perfect. In cases of abnormal termination, it is possible to recover the file that was
being processed at the moment blackcat has aborted. The command is pretty simple:

    root@RedBarn:~/sphinx# blackcat undo
    root@RedBarn:~/sphinx# _

Blackcat generates a checkpoint at every file processing (encrypting and decrypting).

In cases when blackcat does not exit normally you should immediately execute an 'undo'.

When there is some file to be recovered you will not be able to process any other file before
executing an 'undo' command.

Getting info about the repo
===========================

If for some reason you want to know some meta-info about your blackcat repo, things such as version,
used hashes, protection layer, etc. Try the command 'info':

    root@RedBarn:~/sphinx# blackcat info
    (some info...)
    root@RedBarn:~/sphinx# _

Your password will be asked before providing the information.

Decoy files
===========

Blackcat has a command that allows you creating decoy files that are totally random but for an
unsuspecting attacker is almost impossible to separate this kind of data from real cryptograms.
The most obvious utility of decoy files is to add noise during a possible repo cryptanalysis.
Maybe a cryptanalyst could spend days, months or even years on pure chaff. The usage is as follows:

    root@RedBarn:~/sphinx# blackcat decoy chunk-001.txt chunk-002.txt --fsize=4096
    root@RedBarn:~/sphinx# _

The 'decoy' command for avoiding data loss does not overwrite files automatically you need to explicity
ask for it through '--overwrite' flag option:

    root@RedBarn:~/sphinx# blackcat decoy chunk-001.txt chunk-002.txt --fsize=8192 --overwrite
    root@RedBarn:~/sphinx# _

If you are using some kind of encoding for your sensitive data is a good idea also generate encoded
decoys (using the same encoded algorithm used for sensitive data, of course):

    root@RedBarn:~/sphinx# blackcat decoy doc/report.txt --encoder=uuencode --fsize=193
    root@RedBarn:~/sphinx# _

After doing it all you should do is to add the generated decoy files as plain files to the repo's
catalog by using the command 'add'.

Tip[0]: decoy can be only generated into a previous well-initialized repo.

Tip[1]: as default blackcat will detect the current picked encoder for you, however, if for some reason
you want to use a different one, force its usage through the '--encoder' option.

Tip[2]: if you are using the cascade type one-time pad instead of single flow, blackcat will generate
decoys following the PEM output format used by the otp cascade type.

Promoting a plausibly deniable encryption with some blackcat primitives
=======================================================================

There are three primitives strategically implemented in blackcat that allows you to create a repo
with deniable crypto. Those primitives (or commands) are: 'decoy', 'detach' and 'attach'.

The 'decoy' command was already introduced. The 'detach' commnand makes possible the "extraction"
of the metainfo present into a blackcat repo (the encrypted catalog containing all information
necessary to properly access the repo's data). After extracting those metainfo to an ordinary file,
the repository becomes an ordinary folder again.

Opposingly the 'attach' command takes a metainfo previously extracted through detach. Turning into
an ordinary folder a blackcat repo again.

This locking swap allows you put information that is valid by using a key but invalid by using
(an)other one(s). Also you can put files that are invalid when decrypted by any key (decoy files).
The possibility of put a decoy file adds more deniability to your stuff.

Let's suppose Alice wants to create a repository that has information not much favorable about
Bob. However, Bob controls any information that Alice creates.

Firstly, Alice will create from scrath a repo:

    alice@RedBarn:~/wonderland# blackcat init \
    > --catalog-hash=sha3-512 --key-hash=whirlpool --protection-layer-hash=tiger \
    > --protection-layer=hmac-sha-384-aes-256-cbc,blowfish-cbc,aes-192-cbc
    > --encoder=uuencode
    alice@RedBarn:~/wonderland# _

Alice creates plenty of files, including: '001.txt', '002.txt', '003.txt'.

Those files have information that gathers her bad impressions about Bob. Alice adds those
files as protected files:

    alice@RedBarn:~/wonderland# blackcat add 001.txt 002.txt 003.txt --lock
    alice@RedBarn:~/wonderland# _

Alice would let her data in this state but seeing which way the black cat jumps (sorry).
She decided to add some decoy files. She adds pure chaff from '004.txt' to '020.txt':

    alice@RedBarn:~/wonderland# blackcat decoy 004.txt --encoder=uuencode --fsize=512
    alice@RedBarn:~/wonderland# blackcat decoy 005.txt --encoder=uuencode --fsize=896
    alice@RedBarn:~/wonderland# blackcat decoy 006.txt --encoder=uuencode --fsize=1024
    alice@RedBarn:~/wonderland# blackcat decoy 007.txt --encoder=uuencode --fsize=4096
    alice@RedBarn:~/wonderland# blackcat decoy 008.txt --encoder=uuencode --fsize=8192
    alice@RedBarn:~/wonderland# blackcat decoy 009.txt --encoder=uuencode --fsize=64
    alice@RedBarn:~/wonderland# blackcat decoy 010.txt --encoder=uuencode --fsize=128
    alice@RedBarn:~/wonderland# blackcat decoy 011.txt --encoder=uuencode --fsize=837
    alice@RedBarn:~/wonderland# blackcat decoy 012.txt --encoder=uuencode --fsize=100
    alice@RedBarn:~/wonderland# blackcat decoy 013.txt --encoder=uuencode --fsize=167
    alice@RedBarn:~/wonderland# blackcat decoy 014.txt --encoder=uuencode --fsize=200
    alice@RedBarn:~/wonderland# blackcat decoy 015.txt --encoder=uuencode --fsize=256
    alice@RedBarn:~/wonderland# blackcat decoy 016.txt --encoder=uuencode --fsize=1000
    alice@RedBarn:~/wonderland# blackcat decoy 017.txt --encoder=uuencode --fsize=2048
    alice@RedBarn:~/wonderland# blackcat decoy 018.txt --encoder=uuencode --fsize=192
    alice@RedBarn:~/wonderland# blackcat decoy 019.txt --encoder=uuencode --fsize=999
    alice@RedBarn:~/wonderland# blackcat decoy 020.txt --encoder=uuencode --fsize=101
    alice@RedBarn:~/wonderland# _

After creating some decoys she needs to add them to the catalog but she adds them as plain files:

    alice@RedBarn:~/wonderland# blackcat add \
    > 004.txt 005.txt 006.txt 008.txt \
    > 009.txt 010.txt 011.txt 012.txt \
    > 013.txt 014.txt 015.txt 016.txt \
    > 017.txt 018.txt 019.txt 020.txt --plain
    alice@RedBarn:~/wonderland# _

Now she also create some decoys that are actually protected but is pure dummy chaff, too.

    alice@RedBarn:~/wonderland# blackcat decoy 021.txt --fsize=1024
    alice@RedBarn:~/wonderland# blackcat decoy 022.txt --fsize=2048
    alice@RedBarn:~/wonderland# blackcat decoy 023.txt --fsize=4096
    alice@RedBarn:~/wonderland# blackcat decoy 024.txt --fsize=8192
    alice@RedBarn:~/wonderland# blackcat decoy 025.txt --fsize=64
    alice@RedBarn:~/wonderland# blackcat decoy 026.txt --fsize=128

After it she needs to add them to the catalog as "protected garbage":

    alice@RedBarn:~/wonderland# blackcat add 021.txt 022.txt 023.txt 024.txt \
    > 025.txt 026.txt --lock

Now Alice runs a status command in order to see if everything is really protected:

    alice@RedBarn:~/wonderland# blackcat status
    alice@RedBarn:~/wonderland# _

Since everything is protected she decides to remove the repo metainfo by saving it in a
secure place:

    alice@RedBarn:~/wonderland# blackcat detach --dest=/home/alice/secure-data/wonderland.k0
    alice@RedBarn:~/wonderland# _

But Bob will ask her to decrypt the content before allowing her to send out those data out there.
Due to it Alice creates files talking only good things about Bob, contradicting any bad information
that she knows. She decided to dedicate some time creating good reports from '027.txt' until '050.txt':

Now she needs to protect them with another key:

    alice@RedBarn:~/wonderland# blackcat init \
    > --catalog-hash=sha-512 --key-hash=sha3-512 --protection-layer-hash=whirlpool \
    > --protection-layer=blowfish-ctr,aes-192-cbc,hmac-sha-224-blowfish-cbc
    > --encoder=uuencode --keyed-alike
    alice@RedBarn:~/wonderland# _

Once the init done, she adds the files '027.txt'..'050.txt' as protected files:

    alice@RedBarn:~/wonderland# blackcat add \
    > 027.txt 028.txt 029.txt \
    > 030.txt 031.txt 032.txt 033.txt 034.txt 035.txt 036.txt 037.txt 038.txt 039.txt \
    > 040.txt 041.txt 042.txt 043.txt 044.txt 045.txt 046.txt 047.txt 048.txt 049.txt \
    > 050.txt --lock

She also needs to add the real information (001.txt, 002.txt, 003.txt) to the catalog, but
in this case, just as plain files (they will be alleged decoy files):

    alice@RedBarn:~/wonderland# blackcat add 001.txt 002.txt 003.txt --plain
    alice@RedBarn:~/wonderland# _

She knows that the information in 001.txt, 002.txt and 003.txt will not change anymore,
so in the dummy catalog it can be just plain stuff. In other scenarios it would be better
to process them as protected chaff (the encoding algorithm should be dropped).

Alice also add all other decoy from the original repo's catalog as plain files:

    alice@RedBarn:~/wonderland# blackcat add \
    > 004.txt 005.txt 006.txt 008.txt \
    > 009.txt 010.txt 011.txt 012.txt \
    > 013.txt 014.txt 015.txt 016.txt \
    > 017.txt 018.txt 019.txt 020.txt \
    > 021.txt 022.txt 023.txt 024.txt \
    > 025.txt 026.txt --plain
    alice@RedBarn:~/wonderland# _

She also creates protected chaff in this catalog from 051.txt up to 064.txt:

    alice@RedBarn:~/wonderland# blackcat decoy 051.txt --fsize=1024
    alice@RedBarn:~/wonderland# blackcat decoy 052.txt --fsize=2048
    alice@RedBarn:~/wonderland# blackcat decoy 053.txt --fsize=4096
    alice@RedBarn:~/wonderland# blackcat decoy 054.txt --fsize=8192
    alice@RedBarn:~/wonderland# blackcat decoy 055.txt --fsize=64
    alice@RedBarn:~/wonderland# blackcat decoy 056.txt --fsize=128
    alice@RedBarn:~/wonderland# blackcat decoy 057.txt --fsize=512
    alice@RedBarn:~/wonderland# blackcat decoy 058.txt --fsize=256
    alice@RedBarn:~/wonderland# blackcat decoy 059.txt --fsize=192
    alice@RedBarn:~/wonderland# blackcat decoy 060.txt --fsize=128
    alice@RedBarn:~/wonderland# blackcat decoy 061.txt --fsize=103
    alice@RedBarn:~/wonderland# blackcat decoy 062.txt --fsize=18
    alice@RedBarn:~/wonderland# blackcat decoy 063.txt --fsize=78
    alice@RedBarn:~/wonderland# blackcat decoy 064.txt --fsize=92

Now she adds those new chaff to the catalog as protected data:

    alice@RedBarn:~/wonderland# blackcat add 051.txt 052.txt 053.txt 054.txt \
    > 055.txt 056.txt 057.txt 058.txt 059.txt 060.txt 061.txt 062.txt \
    > 063.txt 064.txt --lock
    alice@RedBarn:~/wonderland# _

Since everything is currently protected, Alice also extracts the current metainfo
from this dummy catalog:

    alice@RedBarn:~/wonderland# blackcat detach --dest=/home/alice/secure-data/wonderland.k1
    alice@RedBarn:~/wonderland# _

Alice decides to add a second dummy catalog. Doing it she is able to gives Bob two keys instead
of one that decrypts to the alleged valid content. So:

    alice@RedBarn:~/wonderland# blackcat init \
    > --catalog-hash=tiger --key-hash=sha-384 --protection-layer-hash=sha3-224 \
    > --protection-layer=hmac-sha-256-aes-128-cbc
    > --encoder=uuencode --keyed-alike
    alice@RedBarn:~/wonderland# _

She creates ten files with some fake secret information (065.txt .. 075.txt). Just after she
adds them as protected files to the current attached catalog:

    alice@RedBarn:~/wonderland# blackcat add 065.txt 066.txt 067.txt 068.txt 069.txt \
    > 070.txt 071.txt 072.txt 073.txt 074.txt 075.txt --lock
    alice@RedBarn:~/wonderland# _

After it she generates five protected decoy files:

    alice@RedBarn:~/wonderland# blackcat decoy 076.txt --fsize=17
    alice@RedBarn:~/wonderland# blackcat decoy 077.txt --fsize=103
    alice@RedBarn:~/wonderland# blackcat decoy 078.txt --fsize=1024
    alice@RedBarn:~/wonderland# blackcat decoy 079.txt --fsize=3096
    alice@RedBarn:~/wonderland# blackcat decoy 080.txt --fsize=2093
    alice@RedBarn:~/wonderland# blackcat add 076.txt 077.txt 078.txt 079.txt 080.txt --lock
    alice@RedBarn:~/wonderland# _

Now she creates more twenty decoys:

    alice@RedBarn:~/wonderland# blackcat decoy 081.txt --encoder=uuencode --fsize=512
    alice@RedBarn:~/wonderland# blackcat decoy 082.txt --encoder=uuencode --fsize=183
    alice@RedBarn:~/wonderland# blackcat decoy 083.txt --encoder=uuencode --fsize=278
    alice@RedBarn:~/wonderland# blackcat decoy 084.txt --encoder=uuencode --fsize=10
    alice@RedBarn:~/wonderland# blackcat decoy 085.txt --encoder=uuencode --fsize=52
    alice@RedBarn:~/wonderland# blackcat decoy 086.txt --encoder=uuencode --fsize=12
    alice@RedBarn:~/wonderland# blackcat decoy 087.txt --encoder=uuencode --fsize=92
    alice@RedBarn:~/wonderland# blackcat decoy 088.txt --encoder=uuencode --fsize=1024
    alice@RedBarn:~/wonderland# blackcat decoy 089.txt --encoder=uuencode --fsize=276
    alice@RedBarn:~/wonderland# blackcat decoy 090.txt --encoder=uuencode --fsize=293
    alice@RedBarn:~/wonderland# blackcat decoy 091.txt --encoder=uuencode --fsize=32
    alice@RedBarn:~/wonderland# blackcat decoy 092.txt --encoder=uuencode --fsize=62
    alice@RedBarn:~/wonderland# blackcat decoy 093.txt --encoder=uuencode --fsize=9
    alice@RedBarn:~/wonderland# blackcat decoy 094.txt --encoder=uuencode --fsize=22
    alice@RedBarn:~/wonderland# blackcat decoy 095.txt --encoder=uuencode --fsize=62
    alice@RedBarn:~/wonderland# blackcat decoy 096.txt --encoder=uuencode --fsize=91
    alice@RedBarn:~/wonderland# blackcat decoy 097.txt --encoder=uuencode --fsize=42
    alice@RedBarn:~/wonderland# blackcat decoy 098.txt --encoder=uuencode --fsize=102
    alice@RedBarn:~/wonderland# blackcat decoy 099.txt --encoder=uuencode --fsize=384
    alice@RedBarn:~/wonderland# blackcat decoy 100.txt --encoder=uuencode --fsize=224

She also adds those decoys as plain files:

    alice@RedBarn:~/wonderland# blackcat add 081.txt 082.txt 083.txt \
    > 084.txt 085.txt 086.txt 087.txt 088.txt 089.txt 090.txt 091.txt \
    > 092.txt 093.txt 094.txt 095.txt 096.txt 097.txt 098.txt 099.txt 100.txt --plain
    alice@RedBarn:~/wonderland# _

She also adds the files 001.txt .. 064.txt as plain data, too:

    alice@RedBarn:~/wonderland# blackcat add 001.txt 002.txt 003.txt \
    > 004.txt 005.txt 006.txt 007.txt 008.txt 009.txt 010.txt 011.txt \
    > 012.txt 013.txt 014.txt 015.txt 016.txt 017.txt 018.txt 019.txt \
    > 020.txt 021.txt 022.txt 023.txt 024.txt 025.txt 026.txt 027.txt \
    > 028.txt 029.txt 030.txt 031.txt 032.txt 033.txt 034.txt 035.txt \
    > 036.txt 037.txt 038.txt 039.txt 040.txt 041.txt 042.txt 043.txt \
    > 044.txt 045.txt 046.txt 047.txt 048.txt 049.txt 050.txt 051.txt \
    > 052.txt 053.txt 054.txt 055.txt 056.txt 057.txt 058.txt 059.txt \
    > 060.txt 061.txt 062.txt 063.txt 064.txt --plain
    alice@RedBarn:~/wonderland# _

She detaches this catalog too:

    alice@RedBarn:~/wonderland# blackcat detach --dest=/home/alice/secure-data/wonderland.k2
    alice@RedBarn:~/wonderland# _

Now let's suppose that when asked to allow Alice to send out data, Bob asks her for the key.
Alice presents the wonderland.k1 content as the main repository "key" and additionally she
presents wonderland.k2 as the dummy "key". She saves a copy to Bob of those metainfos in
'wonderland.main.metainfo', 'wonderland.dummy.metainfo' files and send them to Bob.
So Bob will test it. First he will inspect the dummy data:

    bob@BigBo:~/data-inspection/alice# blackcat attach \
    > --src=/home/bob/data/policy/alice/wonderland.dummy.metainfo
    bob@BigBo:~/data-inspection/alice# _

Alice has provided him the repo's master keys for the two sent metainfos, so Bob only needs
to run a "hungry lock" and eavesdrop everything:

    bob@BigBo:~/data-inspection/alice# blackcat lock
    bob@BigBo:~/data-inspection/alice# _

Everything looks fine with the dummy data, no disclosures about him, etc. Now he will inspect
the "real" sensitive data:

    bob@BigBo:~/data-inspection/alice# blackcat attach \
    > --src=/home/bob/data/policy/alice/wonderland.main.metainfo
    bob@BigBo:~/data-inspection/alice# _

Now he unlocks all data and inspects:

    bob@BigBo:~/data-inspection/alice# blackcat lock
    bob@BigBo:~/data-inspection/alice# _

After reading what Alice has wrote about him, with tears in his eyes, Bob allows Alice to
send out every information. The data was approved.

This scenario is pretty unreal for most of people, in many cases, the key will be asked after
the data was sent, in this case Alice will not face the risk of Bob censor her decoy files.
Otherwise it would be better Alice apply some steganography over the decoy data, too.
It is out of the scope of this manual.

Untouching files
================

Time attributes can be harmful when you really want to promote a deniable encryption. Because by the access, modification or
creation time an attacker can get a lot of useful information in order to separate want is a decoy and what is the real files.

Blackcat implements the command 'untouch' in order to mitigate this problem, the usage is straightforward:

    alice@RedBarn:~/wonderland# blackcat untouch 0101.txt report/002.txt abc/xyz.jpeg yyz/*.pdf
    alice@RedBarn:~/wonderland# _

The command presented does not set the creation time. If you also want to set it you should use the flag '--hard' when
executing untouch:

    alice@RedBarn:~/wonderland# blackcat untouch *.txt --hard
    alice@RedBarn:~/wonderland# _

The untouch command will set the time attribute to the "blackcat epoch" (11/05/1970 16:05:00).

When --hard is specified all directories of the repository including the .bcrepo metadata directory have their
access and modification times set to "blackcat epoch".

Always when you lock/unlock files, set any attribute or even read/write it directly, the time attributes will change. So if
you really want to let a null time information to a possible attacker, the command untouch must be the last command. After
locking every sensitive data run a untouch command over the whole repo or at least over data you judge more sensible.

Protecting network traffic
==========================

Blackcat is able to protect data flowing from network connections. The basic idea behind the net
module is to protect applications by running them through blackcat. In this case any socket function
related to send/receive data is intercepted by 'libbcsck.so', the library with socket stuff but including
some crypto capabilities.

When you protect network traffic with blackcat you must indicate which protection rule will be applied over
that communication channel. Due to it you need to create a rule and store this rule inside a file that is
commonly called 'netdb'. A kind of database with rules that can protect net data.

The command for creating a rule is 'net/--add-rule':

    root@RedBarn:~/# blackcat net --add-rule --rule=nc --type=socket --hash=whirlpool \
    > --protection-layer=blowfish,aes-128-ctr,hmac-sha3-512-aes-256-cbc --db-path=netdb.db

It will create a file called 'netdb.db' with a rule called 'nc' of type 'socket'. Until now only type
'socket' is supported. The '--protection-layer' option specifies what algorithm(s) will be used for
protecting data. The '--hash' option indicates the hash algorithm used by the key derivation function.

When you specify an existing file in the '--db-path' option your new rule will be appended to the
existing ones.

If for some reason you want to delete a rule:

    root@RedBarn:~/# blackcat net --drop-rule --rule=nc --db-path=netdb.db

Pretty easy, huh?

Now let's see how to use a rule for protecting a connection. As said before blackcat will apply
some hooking stuff in order to make the connection encrypted. Let's suppose that Alice wants to
communicate with Bob just by using netcat but she also wants some level of secrecy during this
chat. Alice should use the command 'net/--run' in order to create a protected instance of netcat
in her system:

    alice@RedBarn:~/# blackcat net --run --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc -l -p 1024

Just after executing the command above Alice will be asked for the netdb's password and also a
session key (previously agreed between Bob and her). Notice that the command invoking the external
application must be passed after all blackcat options.

Bob also runs the netcat wrapped by blackcat. Indicating the same netdb rule and session key
agreed with Alice:

    bob@SkyValley:~/# blackcat net --run --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc alice.workstation 1024

After the connection is well estabilished, every data exchanged between each other will be
encrypted following the netdb rule.

The option '--bcsck-lib-path' can be omitted and by default blackcat will scan its socket library
in '/usr/lib'. If you want to overwrite the default you should define an environment variable called
'BLACKCAT_BCSCK_LIB_HOME'.

Similarly, the option '--db-path' can be omitted when you define an environment variable called
'BLACKCAT_NET_DB_HOME'.

BEWARE: The 'net/--run' sample given above does not protect you against replay attacks. If you
want to protect the communication against this kind of attack you should flag your intention by
using the option flag '--e2ee'. This will force the blackcat use an ephemeral key for each
exchanged data. The command becomes a little bit different:

    alice@RedBarn:~/# blackcat net --run --e2ee --xchg-port=50 --rule=nc \
    > --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc -l -p 1024

Now Alice has used '--e2ee' option and also she has indicated a control port number through the
option '--xchg-port'. This port number will be used during a necessary initial negotiation.

The command for Bob also changes a little:

    bob@SkyValley:~/# blackcat net --run --e2ee --xchg-port=50 --xchg-addr=alice.workstation \
    > --rule=nc --bcsck-lib-path=/usr/lib/libbcsck.so \
    > --db-path=/usr/local/share/blackcat/db/netdb.db nc alice.workstation 1024

Bob, being the client must pass three additional flags: '--e2ee', '--xchg-port' and '--xchg-addr'.

The '--xchg-port' must contain the same value picked by Alice. The '--xchg-addr' must contain the
Alice's network address.

Once well estabilished the connection, each message exchanged between each other will be encrypted
with a double ratchet mechanism. When some key is re-used a warning is displayed. Alerting the user
about a possible replay attack, in this case is better to close the connection immediately.

Until now '--e2ee' is not available in NetBSD.

The first usage mode also must be considered an end-to-end encryption (E2EE), however, the second
usage ensures a little bit better that nothing can be done with the channel, in regards to data or
connection manipulation.

Cool off
========

Maybe you have heard from someone that knows somebody that have told about the existence of software
able to guess up the used encryption algorithm just by scanning the software used for performing the
encryption. 'Wooow!!'... joking...

Those software just scan the executable text trying to find some algorithm constant which behaves like
a signature. Pretty boring. It is useless and do not offer any risk for well implemented crypto, since
modern encryption takes into consideration the Kasiski's principles. Thus even knowing the used
algorithm, if the attacker does not know the key, the attack must be infeasible by her/him.

Of course that blackcat has all constants of all implemented algorithms in its text. What an attacker
should do is to perform a brute force against the first key and if there is a second key they must
guess up the algorithm(s) (when more than one, the right used sequence is necessary, too).

It tends to be a little bit hard because

        "if you don't know where you are going, any road " + may + " get you there"

What the best way of knowing that this specific road is not the right road? Simple, find the end of it.
If at the end you did not find anything. It is time to go back and try another road.

Nice, for the first time Alice was the attacker. Eve was revenged! ;)

Passwords
=========

In blackcat we call 'passwords' keys or even session keys. Anyway, keys provided by users are not
directly used. Thus, over your provided key is always applied some (default or previously configured)
key crunching and/or key derivation function.

The nice part of providing user keys in blackcat is the possibility of easily use the extended ascii
charset. For doing this use the following format:

    '\xXX', where XX are hexadecimal digits. This is not valid -> '\x0\x1\x2' must be '\x00\x01\x02'.

So the key 'abc' also could be provided as: '\x61\x62\x63'.

Of course that you can mix up normal symbols with hexadecimal, such as:

    'abc\x00\x01\x78\xF2\xF1\xF0\xDA\x53.101'

Also is possible to indicade returns through '\r', enters with '\n' and tabulations as '\t'.

So there is no excuse for not using more entropic keys, if you want to.

Exchanging session keys
=======================

Blackcat implements a well simple vpn-tunnel for applications that do not offer any encryption
convenience. Sometimes agree a session key in a more secure way is a problem.

Considering this issue blackcat implements a modified Diffie-Hellman-Merkle key exchange scheme.
This scheme mitigates a little the man-in-the-middle attacks against the standard one.

In order to exchange a session key with blackcat, firstly, is necessary to create a key pair
through the net subcommand '--mk-dh-key-pair'. The most straightforward way of using it is:

    alice@WolandsLand:~/# blackcat net --mk-dh-key-pair --public-key-out=alice.pub \
    > --private-key-out=alice.priv --use-dh-group --group-bits=2048
    alice@WolandsLand:~/# _

Once succeeded the command above, all Alice should do is to make public the 'alice.pub' file.
Anyone who wants to exchange information with her must use this public file.

Alice should never make public the 'alice.priv' file, because this file will "unlock" any
information "locked" by using 'alice.pub'. The 'alice.priv' file is encrypted with
a key asked to her while generating it.

Even so, if your private parameters was disclosed I recommend you to generate a new key pair.

The key pair making command shown above uses standarnized MODP parameters for
Diffie-Hellman-Merkle. Until now you can use group bits of 1536, 2048, 3072, 4096,
6144 or 8192 bits. However, you can also create your own DH parameters in the following way:

    alice@WolandsLand:~/# blackcat net --mk-dh-params --p-bits=1024 --q-bits=256 \
    > --out=dh-params.txt
    alice@WolandsLand:~/# _

Now in order to create a key pair by using those parameters instead of a standanized MODP
group, you should:

    alice@WolandsLand:~/# blackcat net --mk-dh-key-pair --public-key-out=alice.pub \
    > --private-key-out=alice.priv --dh-params-in=dh-params.txt
    alice@WolandsLand:~/# _

Now, let's suppose that Bob wants to exchange a session key that will be used between Alice
and him during one month:

    Bob@Copacabana:~/# blackcat net --skey-xchg --server --kpub=alice.pub --port=5002 \
    > --bits=160
    Bob@Copacabana:~/# _

Bob will be asked for a session key, so he provides it besides confirming it too. The data will
be processed and encrypted in a way that only Alice should be able to decrypt.

At Alice's side, she knows the address and port that Bob is waiting for exchanging data with her:

    Alice@WolandsLand:~/# blackcat net --skey-xchg --addr=Copacabana --port=5002 \
    > --kpriv=alice.priv
    Alice@WolandsLand:~/# _

Once received all parameters, the blackcat instance executed in Alice's system will tell her the
agreed session key (initially defined by Bob in him system). Now the two parts have estabilished
their "monthly key".

It is also possible to estabilish a random session key, instead of estabilishing a static one
when executing 'net/--run' command.

Supposing Alice wants to communicate with Bob through netcat. Alice previously send
to Bob her public parameters ('alice.pub'). So she asks Bob to run netcat in his system
listening for her connection at port 1009 and listening for session key exchanging stuff
at port 5003:

    Bob@Copacabana:~/# blackcat net --run --e2ee --rule=nc-alice-bob \
    > --bcsck-lib-path=lib/libbcsck.so --db-path=/home/Bob/rules.ndb \
    > --kpub=alice.pub --bits=160 --xchg-port=5003 nc -l -p 1009
    Bob@Copacabana:~/# _

Now Alice in her system uses her private parameters and connects to Bob's host:

    alice@WolandsLand:~/# blackcat net --e2ee --rule=nc-alice-bob \
    > --bcsck-lib-path=lib/libbcsck.so --db-path=/home/Alice/rules.ndb \
    > --kpriv=alice.priv --xchg-addr=Copacabana --xchg-port=5003 nc Copacabana 1009
    alice@WolandsLand:~/# _

Done. They have estabilished a secure chat session. Now Netcat is using strong encryption
with ephemeral keys per message.

The .bcrepo/CONFIG file
=======================

This file is intended to hold specific configurations of a repository. Due to security issues this file
is not automatically loaded. When you create a CONFIG file you must indicate that the current content
can be read and loaded. There is a command for doing it:

    Bob@ConfigSampe:~/config# blackcat config --update
    Bob@ConfigSampe:~/config# _

Notice that everytime you change/add some data to CONFIG file you need to run an update.

If for some reason you do not want the CONFIG file anymore, remove it in the following way:

    Bob@ConfigSampe:~/config# blackcat config --remove
    Bob@ConfigSampe:~/config# _

If you want to check if the CONFIG file has changed since the last edition:

    Bob@ConfigSampe:~/config# blackcat config --check-integrity
    Bob@ConfigSampe:~/config# _

Inside the CONFIG file the configuration is divided into sections. A section is merely a label
following this form: 'label:'. The configuration data can be words or lines.

A word is separated by spaces, tabulations or line feeds. A line is separated by line feed.

A section is ended by two consecutive line feeds. Sample of a section:

    'sample:
        word0 word1
        line0
        line1
        last_line

    '

Defining default arguments for any command executed into a repository
=====================================================================

Blackcat has some default arguments that can be used with any command. In order to avoid typing
every single time this option explicitly. You can load and include this option through 'CONFIG/default-args'.

Let's avoid RAM swap for every blackcat command. The 'default-args' section expects words, each word must be
a well-known blackcat command line option. So let's open the .bcrepo/CONFIG and add the following section:

    'default-args:
        --no-swap

    '

    Alice@DefaultArgsLoading:~/sample# blackcat config --update
    Alice@DefaultArgsLoading:~/sample# _


Now the option '--no-swap' will be included when running any command inside those repo.

User defined commands
=====================

Sometimes depending on the workflow and the repo layout there will be commands that could be executed
repeatedly. You can define those set of commands or macros and call it by using a pseudo-command name
also defined by you. It can be done by using 'CONFIG/user-commands'.

The section 'user-commnads' registers a user set of commands. The set of commmands is merely another
section having a command per line. The section name will be the pseudo-command name.

Supposing that Alice has files inside sub-directory src and when she re-encrypt it she also needs to
untouch all files inside there.

    'user-commands:
        decrypt-src
        encrtpt-src

    decrypt-src:
        blackcat unlock src/*

    encrypt-src:
        blackcat lock src/*
        blackcat untouch src/* --hard

    '

Now Alice has to run and update:

    Alice@WonderLandLabs:~/crazy-stuff# blackcat config --update

There is a suggestive blackcat command that executes pre-defined user commands: 'do'.

According to this sample Alice can decrypt all files under src by doing:

    Alice@WonderLandLabs:~/crazy-stuff# blackcat do --decrypt-src

and encrypt and untouching just by doing:

    Alice@WonderLandLabs:~/crazy-stuff# blackcat do --encrypt-src

It is also possible to execute any shell command. Do not worry because when someone changes the CONFIG
file this change will be detected and the CONFIG data will not be loaded. Since the update process
requires the repo password only you will be able to actually change the CONFIG file.

Using a KDF in order to derive your protection layer keys
=========================================================

On version 1.2.0 blackcat started implementing the possibility of using some standard KDF instead of
its regular method of deriving keys from user's master/second layer key.

Until now there are three available algorithms: HKDF, PBKDF2 and ARGON2I.

In order to use one of them in replacement of the standard internal method you need to specify this
intention at the repo initializing moment. The option which indicates this intention is '--kdf'. It
should be set to the desired key derivation function algorithm ('hkdf', 'pbkdf2' or 'argon2i').

Depending on the picked algorithm will be necessary other additional parameters:

    +-----------+--------------------------+----------------------------------------------------+
    | Algorithm |   Additional parameters  |                   Description                      |
    +-----------+--------------------------+----------------------------------------------------+
    |           | --hkdf-hash=<hash>       | Specifies the hash function used by HKDF           |
    |           |                          | --protection-layer-hash is considered when         |
    |           |                          | --hkdf-hash is not passed.                         |
    |           |                          +----------------------------------------------------+
    |   HKDF    | --hkdf-salt=<data>       | Specifies data used as salt.                       |
    |           |                          | Extended ascii can be expressed as hexadecimals    |
    |           |                          | in the following way: \xXX.                        |
    |           |                          +----------------------------------------------------+
    |           | --hkdf-info=<data>       | Specifies the info parameter of HKDF.              |
    |           |                          | Similarly --hkdf-salt it accepts extended ascii.   |
    +-----------+--------------------------+----------------------------------------------------+
    |           | --pbkd2-hash=<hash>      | Specifies the hash function used by HKDF           |
    |           |                          | --protection-layer-hash is considered when         |
    |           |                          | --pbkdf2-hash is not passed.                       |
    |           |                          +----------------------------------------------------+
    |  PBKDF2   | --pbkdf2-salt=<data>     | Specifies data used as salt by PBKDF2. It accepts  |
    |           |                          | extended ascii.                                    |
    |           |                          +----------------------------------------------------+
    |           | --pbkdf2-count=<n>       | Specifies the count parameter of PBKDF2. It should |
    |           |                          | be a valid decimal number.                         |
    +-----------+--------------------------+----------------------------------------------------+
    |           | --argon2i-salt=<data>    | Specifies data used as salt by ARGON2I. It accepts |
    |           |                          | extended ascii.                                    |
    |           |                          +----------------------------------------------------+
    |           | --argon2i-memory=<n>     | Specifies the memory parameter used by ARGON2I. It |
    |           |                          | should be a valid decimal number. When not passed  |
    |           |                          | the default "8" is taken.                          |
    |           |                          +----------------------------------------------------+
    |  ARGON2I  | --argon2i-iterations=<n> | Specifies the total of iterations done by ARGON2I. |
    |           |                          | It should be a valid decimal number.               |
    |           |                          +----------------------------------------------------+
    |           | --argon2i-key=<data>     | Specifies the key used by ARGON2I. The passed data |
    |           |                          | can be extended ascii.                             |
    |           |                          +----------------------------------------------------+
    |           | --argon-aad=<data>       | Specifies the associated data used by ARGON2I. The |
    |           |                          | passed data can be extended ascii.                 |
    +-----------+--------------------------+----------------------------------------------------+

Follows an example of a init command which specifies a KDF function:

    Alice@CraterLake:~/sample# blackcat init --key-hash=sha3-512 \
    > --catalog-hash=blake2s-256 \
    > --protection-layer-hash=sha-512 \
    > --kdf=hkdf \
    > --hkdf-salt=GhostBeach \
    > --hkdf-info=Catamaran \
    > --protection-layer=aes-128-cbc,camellia-192-cbc --keyed-alike
    Alice@CraterLake:~/sample# _

Now let's suppose that Alice wants to change the KDF from HKDF to ARGON2I:

    Alice@CraterLake:~/sample# blackcat setkey --kdf=argon2i \
    > --argon2i-salt=IMakeWierdChoices \
    > --argon2i-key=Maced0n14nLines \
    > --argon2i-iterations=20 \
    > --argon2i-aad=SonnyBonoMemorialFreeway \
    > --protection-layer=aes-128-cbc,camellia-192-cbc --keyed-alike
    Alice@CraterLake:~/sample# _

In the last command sample we got a rule of thumb for KDF changing:

        * When changing anything related to KDFs you need to specify the protection layer. Otherwise
          you will got an error.

Now let's suppose that Alice does not want a KDF anymore:

    Alice@CraterLake:~/sample# blackcat setkey --no-kdf \
    > --protection-layer=aes-128-cbc,camellia-192-cbc --keyed-alike
    Alice@CraterLake:~/sample# _

Even when you want to just remove the KDF usage, the protection-layer passing is necessary. When
no KDF is specified the internal stantard derivation method is used instead.

Getting piped status output
===========================

When your repo's catalog starts growing maybe the status output become hard to handle in a single
output page screen, thus, what about getting the whole status output directed to less or more
applications?

In order to do that just create the config section "status-viewer" in '.bcrepo/CONFIG'. This
section must hold the end pipe command. Something like:

    'status-viewer:
        less

    '

Once it defined into your '.bcrepo/CONFIG' all status output will be redirected to your defined viewer.

Using soft-tokens
=================

Blackcat allows you to use soft-tokens that are combined with the keys. In this way, even knowing the
key(s) but without the soft-token(s) in the right order is virtually impossible decrypt the repository
data.

Soft-tokens are related to regular files carring some byte sequence. It can be a plain text, part of a
book, a poem, a picture, a song, random bytes, whatever.

If you want to generate a file with random bytes you can use the command 'token':

    Bob@OobyDooby:~/sample# blackcat token \
    > /mnt/my-ooby-dooby-tokens/ooby.dat /mnt/my-ooby-dooby-tokens/dooby.dat --bytes=512

The command sample above will generate two files ('ooby.dat', 'dooby.dat' within /mnt/my-ooby-dooby-tokens
directory) containing 512 bytes of random data.

The 'token' command can overwrite file(s) if the option '--overwrite' is passed. Being careful when overwrite
a token file, make sure that it is not being used to access any relevant blackcat repo.

In order to use soft-tokens with your key(s) you need to specify this intention at the time of the repository
initialization:

    Bob@OobyDooby:~/sample# blackcat init --catalog-hash=blake2s-256 \
    > --key-hash=tiger \
    > --protection-layer-hash=sha3-512 \
    > --protection-layer=blowfish-cbc,arc4,aes-128-gcm \
    > --encoder=uuencode \
    > --soft-token=/mnt/my-ooby-dooby-tokens/ooby.dat,/mnt/my-ooby-dooby-tokens/dooby.dat

The option '--soft-token' specifies the token files and their usage sequence.

After initializing a repo with soft-tokens any operation that requires the user key(s) will also
require the tokens in the sequence specified at the time of the init operation. Thus, store those tokens
in a safe place and remember their sequence in '--soft-token' option.

Supposing Bob wants to add (and lock) a file to sample's catalog:

    Bob@OobyDooby:~/sample# blackcat add LonesomeStoney.txt --lock \
    > --soft-token=/mnt/my-ooby-dooby-tokens/dooby.dat,/mnt/my-ooby-dooby-tokens/ooby.dat

The command above will not run accordingly due to authentication issues. Notice the wrong tokens sequence.
Now the following one will be successfuly executed:

    Bob@OobyDooby:~/sample# blackcat add LonesomeStoney.txt --lock \
    > --soft-token=/mnt/my-ooby-dooby-tokens/ooby.dat,/mnt/my-ooby-dooby-tokens/dooby.dat

When you want to set new tokens you must use the option 'new-soft-token' in command 'setkey':

    Bob@OobyDooby:~/sample# blackcat setkey \
    > --new-soft-token=/mnt/my-ooby-dooby-tokens/tell.dat,/mnt/my-ooby-dooby-tokens/me.dat
    > --soft-token=/mnt/my-ooby-dooby-tokens/ooby.dat,/mnt/my-ooby-dooby-tokens/dooby.dat

Notice that even during a setkey, the current configured tokens must be passed.

If you want to remove the soft-token(s) usage from a repository, you must run a 'setkey' command
without '--new-soft-token' option.

You can make the usage of soft-tokens more easy by using the config option '.bcrepo/CONFIG/default-args'.
Something like this:

    'default-args:
        --soft-token=/mnt/my-ooby-dooby-tokens/ooby.dat,/mnt-my-ooby-dooby-tokens/dooby.dat

    '

After running an update command over the current CONFIG file data, you will be able to handle the repository
without mind passing the '--soft-token' option with every single command.

How can I access this manual from blackcat?
===========================================

Pretty simple:

    Alice@PerpetualOyster:/home# blackcat man

According to your environment capabilities, blackcat will read and send out the manual data to less, more or
stdout.

Few tips for not being a tracked average sheep out there
========================================================

The nice stuff about blackcat is adding to your workflow the possibility of using strong data protection
with few easy command primitives. It does not require any special container for your data, mounting it,
etc; an ordinary directory becomes protected and you can easily encrypt and decrypt independent files
or file groups. Init it, add and just go.

If you like automating your work, adding blackcat to your state of things is pretty easy.

For example, it is straightforward to integrate blackcat with some scm tool. The nice part is that you
can host a private repository without paying for your privacy. I find privacy is basic, it is a
right and you should not pay for it. In my opinion it is shameful.

Nowadays everyone like sending data to the cloud. However, if you have sensitive stuff or very personal
data you should encrypt it. Do not be fool, believing that all your data is securely stored and that
no one would be able to access it. Systems are full of bugs and people in majority tends to be crooked.
Moreover, some systems/companies just like eavesdropping us because we are profitable while users.
In this case, use the cloud but encrypt what is relevant for you. Also put a bunch of false clues just
for screwing up some nosy AI hahaha I love doing it when hosting data that could be probed. Everyone
should do the same, just for making the web more "friendly" again.

Moreover using crypto is a way of saying: if you want to apply your tracking policy over me you will need
to do it more directed and if you want to track nave people, nice but not me, because I am using some
crypto... Your fishing net must be thinner for catching me up.
